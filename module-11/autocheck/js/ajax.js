/* ======================================================================================================================
AJAX
====================================================================================================================== */

/*AJAX (Asynchronous JavaScript and XML) — 
метод отримання або відправлення даних з 
подальшим оновленням інтерфейсу за цими даними, 
без потреби перезавантаження сторінки. Завдяки 
цьому зменшується час відгуку і вебсторінка 
стає інтерактивнішою.

Цей процес можна розібрати на прикладі завантаження даних.

  1. На вебсторінці відбувається подія (сторінка 
завантажується, натискається кнопка “Показати 
більше”, відправляється форма тощо).
  2. На клієнті за допомогою JavaScript реакцією 
на цю подію буде виконуватися функція для роботи 
з сервером, де створюється і відправляється HTTP-запит.
  3. Сервер отримує й обробляє HTTP-запит, відправляючи 
назад у відповіді дані у форматі JSON.
  4. На клієнті за допомогою JavaScript відповідь 
від сервера обробляється, зчитуються дані і 
оновлюється інтерфейс.


Незважаючи на те, що в назві технології присутній XML, 
у сучасному інтернеті його замінив JSON, а назву 
залишили як данину пам'яті. AJAX трактується як будь-яке 
спілкування з сервером без перезавантаження сторінки.*/

/* ======================================================================================================================
Оновлення інтерфейсу
====================================================================================================================== */

/*Продовжимо працювати з JSONPlaceholder API, щоб 
отримати масив користувачів і відтворити його в інтерфейсі.

Розгляньмо приклад, де є такий HTML:

<button type="button" class="btn">Fetch users</button>
<ul class="user-list"></ul>

При кліку на кнопку Fetch users виконуємо HTTP-запит, 
використовуючи вже знайомий нам метод fetch.
*/

// const fetchUsersBtn = document.querySelector(".btn");

// fetchUsersBtn.addEventListener("click", () => {
//   fetch("https://jsonplaceholder.typicode.com/users")
//     .then((response) => {
//       if (!response.ok) {
//         throw new Error(response.status);
//       }
//       return response.json();
//     })
//     .then((users) => {
// 			// Дані від бекенда
// 			console.log(users);
// 		})
//     .catch((error) => console.log(error));
// });

/*У другому блоці then отримуємо доступ до 
даних відповіді від бекенда. Саме тут можна 
використати ці дані й оновити інтерфейс, 
створити HTML-розмітку і додати її в DOM у 
якийсь уже наявний елемент.

Для створення HTML-розмітки можна використовувати 
будь-який зручний спосіб, наприклад createElement 
або insertAdjacentHTML. Розглянемо одну зі 
стандартних технік.

  1. Перебираємо масив об'єктів методом map.
  2. На кожній ітерації повертаємо HTML-розмітку 
для одного елемента колекції.
  3. Результуючий масив рядків зшиваємо в один 
рядок методом join("").
  4. Додаємо рядок з HTML-розміткою в DOM 
методом insertAdjacentHTML.*/

// const fetchUsersBtn = document.querySelector(".btn");
// const userList = document.querySelector(".user-list");

// fetchUsersBtn.addEventListener("click", () => {
//   fetch("https://jsonplaceholder.typicode.com/users")
//     .then((response) => {
//       if (!response.ok) {
//         throw new Error(response.status);
//       }
//       return response.json();
//     })
//     .then((users) => {
//       const markup = users
//         .map(
//           (user) =>
//             `
//           <li>
//             <p><b>Name</b>: ${user.name}</p>
//             <p><b>Email</b>: ${user.email}</p>
//             <p><b>Company</b>: ${user.company.name}</p>
//           </li>
//         `
//         )
//         .join("");
//       userList.insertAdjacentHTML("beforeend", markup);
//     })
//     .catch((error) => console.log(error));
// });

/*Розбери живий приклад написаного коду. 
Зверни увагу, як ми відрефакторили код, 
щоб зробити його більш читабельним.


  1. Винесли код запиту у функцію fetchUsers(), 
яка виконує HTTP-запит і повертає результат.
  2. В обробнику події кліка ми її викликаємо і 
до результату її виклику додаємо ланцюжок 
методів then() і catch().
  3. Винесли код створення й додавання HTML-розмітки 
у функцію renderUsers(users), яка очікує 
масив користувачів.*/

// const fetchUsersBtn = document.querySelector(".btn");
// const userList = document.querySelector(".user-list");

// fetchUsersBtn.addEventListener("click", () => {
//   fetchUsers()
//     .then((users) => renderUsers(users))
//     .catch((error) => console.log(error));
// });

// function fetchUsers() {
  
//   return fetch("https://jsonplaceholder.typicode.com/users").then(
//     (response) => {

//       if (!response.ok) {
//         throw new Error(response.statusText);
//       }
//       return response.json();
//     }
//   );
// }

// function renderUsers(users) {
//   const markup = users.map((user) => {
//     return `<li>
//       <p><b>Name</b>: ${user.name}</p>
//       <p><b>Email</b>: ${user.email}</p>
//       <p><b>Company</b>: ${user.company.name}</p>
//     </li>`
//   }). join("");
//   userList.insertAdjacentHTML("beforeend", markup);
// }

/* ======================================================================================================================
Помилка новачка
====================================================================================================================== */

/*Розберемо поширену помилку при роботі з 
асинхронним кодом — спробу використовувати 
дані HTTP-запиту поза колбеком методу 
then() у синхронному коді.

Новачок намагається записати «результат fetch» 
у зовнішню змінну і використовувати її нижче 
в синхронному коді відразу після виклику 
методу fetch().*/ 

// let globalVariable; // undefined

// // Виконуємо HTTP-запит
// fetch("https://jsonplaceholder.typicode.com/users")
//   .then(response => response.json())
//   .then(users => {
//     console.log("users inside then callback: ", users);
    
//     // Асинхронно записуємо результат запиту в зовнішню змінну
//     globalVariable = users;

//      // Усередині колбека методу then усе добре
//     console.log("globalVariable inside fetch callback: ", globalVariable);
//   });

// // Зовні колбека методу then у синхронному коді немає доступу до даних асинхронної відповіді бекенда
// console.log("globalVariable outside fetch: ", globalVariable);
// // undefined

/*У нашому прикладі вище поза колбеком методу 
then() даних немає, оскільки останній 
console.log() виконається раніше (синхронний код), 
ніж надійде відповідь від сервера (асинхронний код). 
На момент виклику console.log("globalVariable 
outside fetch: ", globalVariable) змінна 
globalVariable ще має значення undefined. Значення
промісу, що виконався, доступне тільки в асинхронному 
коді, у нашому прикладі це в колбеку методу then().

!!! Тому дуже важливо пам'ятати, що спроба 
записати результат асинхронної операції в зовнішню 
змінну й використовувати його в синхронному коді — 
неефективний підхід. Замість цього краще 
використовувати методи .then() та .catch() для 
обробки результатів асинхронних операцій одразу 
після їх отримання.

Питання
Чи можна отримати доступ до даних HTTP-запиту 
поза методом then у синхронному коді?

Відповідь
Ні, ці дані є значенням промісу, який асинхронно 
обробляється методом then. Такі дані є значенням 
промісу, який обробляється методом then. Якщо ти 
спробуєш зберегти їх у глобальну змінну, ти можеш 
отримати неочікувані результати, такі як undefined, 
оскільки синхронний код виконається раніше, ніж 
проміс буде вирішений.*/ 

/* ======================================================================================================================
Параметри рядка запиту
====================================================================================================================== */

/*Параметри запиту дозволяють вказати бекенду 
додаткові критерії, наприклад:

  1. скільки елементів колекції ми хочемо 
отримати в запиті;
  2. можливо, необхідно додати сортування 
за якоюсь властивістю об'єкта;
  3.обмежити вибірку тощо.

Список параметрів запиту, їх назви і можливі значення 
залежать від бекенду і описані в документації до нього.


Символ ? вказує на початок параметрів запиту. 
Кожен параметр — це пара ім'я=значення.

У рядку запиту параметри між собою розділяються символом &.

У документації JSONPlaceholder API описано можливі 
параметри рядка запиту:

  1. _limit, який контролює кількість 
елементів у відповіді;
  2. _sort, який відповідає за порядок 
сортування об'єктів у масиві.*/

// fetch("https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name")

/*GET-запит у прикладі вище поверне масив із 
семи користувачів (загалом їх 10), відсортованих 
за ім'ям (поле name) за алфавітним порядком. 
Підкреслення в іменах параметрів специфічні 
для цього бекенда, це не якийсь стандарт.

Нижче ми додали використання параметрів рядка 
запиту до живого прикладу.*/ 

// const fetchUsersBtn = document.querySelector(".btn");
// const userList = document.querySelector(".user-list");

// fetchUsersBtn.addEventListener("click", () => {
//   fetchUsers()
//   .then((users) => renderUsers(users))
//   .catch((error) => console.log(error));
// });

// function fetchUsers() {
//   return fetch(
//     "https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name"
//   ).then((response) => {
//     if (!response.ok) {
//       throw new Error(response.status);
//     }
    
//     return response.json();
//   });
// }

// function renderUsers(users) {
//   console.log(users);
  
//   const markup = users.map((user) => {
//     return `
//       <li>
//         <p><b>Name</b> : ${user.name}</p>
//         <p><b>Email</b> : ${user.email}</p>
//         <p><b>Company</b> : ${user.company.name}</p>
//       </li>
//     `
//   }).join("");
//   userList.insertAdjacentHTML("beforeend", markup);
// }

/*Питання
Який символ в URL вказує на початок параметрів рядка запиту?

Відповідь
?
*/ 

/* ======================================================================================================================
Клас URLSearchParams
====================================================================================================================== */

/*Параметрів може бути багато, і незручно складати
з них один довгий рядок як для читабельності, так 
і для його подальшого редагування.

Під час складання рядків параметрів, створюється 
екземпляр класу URLSearchParams та ініціалізується 
об'єктом. Результатом буде спеціальний об'єкт 
(ітератор) з методами, який у рядковому перетворенні 
повертає результат виклику методу toString() — 
своє рядкове відображення.*/

// const searchParams = new URLSearchParams({
//   _limit: 5,
//   _sort: "name",
// });

// console.log(searchParams.toString());
// // _limit=5&_sort=name

// const url = `https://jsonplaceholder.typicode.com/users?${searchParams}`;
// console.log(url);
// // https://jsonplaceholder.typicode.com/users?_limit=5&_sort=name

/*У рядковому вигляді властивості об'єкта стануть 
параметрами та їх значеннями. Параметри будуть 
розділені символом &. У разі інтерполяції значення 
в шаблонних рядках відбувається його неявне перетворення 
в рядок, тому не потрібно викликати метод toString() 
під час складання URL. Не забувай вказувати початок 
рядка запиту символом ?.*/ 