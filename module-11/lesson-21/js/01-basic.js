// ip 172.67.167.151:443

/* ======================================================================================================================
Основи запиту
====================================================================================================================== */

/**
 * Основи запиту
 * - Fetch API
 * - URL запиту
 * - вкладка Network
 * - обробка відповіді response (404 з fetch)
 * 
 * https://jsonplacrholder.typicode.com/todos
 */

/*Як робити запит на сервер?

Для цього є метод, який називається fetch()
Як аргумент у метод передається url-адреса, 
за якою звертаємося.

Метод fetch буде робити запит на сервер.
Запит на сервер не дуже стабільна річ,
тобто сервер може бути вільний або завантажений,
інтернет може бути різний, в залежності від цього
час, через який ви отримаєте відповідь від сервера
може бути різний і тому, як час виконання fetch
може тривати певний час, то наш fetch буде
повертати проміс, тому що запит на сервер асинхронний*/ 

// console.log(fetch("https://jsonplaceholder.typicode.com/todos"));
// // Promise {<pending>}

/*Проміс fetch повернув, тепер його порібно обробити.
Це можна зробити за допомогою 
  1. методу then(), успіх який дочекається поки проміс 
перейде стан fulfilled,  і отримає певні дані
  2. методу catch() - помилка або rejected*/ 

/*then() приймає в себе колбек. Колбек в себе, як параметр
отримає результат, який поверне наш проміс. Назвемо параметр 
response. У response отримаємо обєкт, але не бачимо тих 
данних, які сервер мав повернути(масив з обєктами).
Як їх отримати? Для того, щоб отримати ці дані, ми в response
повинні викликати метод json(), який поверне проміс, отже
його потрібно обробити. Тут в нагоді стає ланцюжок промісів.
Ми можемо із першого then, з його колбека повернути 
виконання методу response.json(), який розпарсить дані і 
перетворить їх у нормальний людський вигляд. Обробимо проміс
методом then, який приймає колбек і параметр data і тепер в 
результаті отримаємо те, що було відпрвлено з сервера, а саме
масив з нашими обєктами

Підсумуємо.
fetch повертає нам якусь відповідь, але в ній є багато різних
властивостей, але немає даних в нормальному вигляді, якими можна було б маніпулювати. Для того щоб їх отримати ми повинні з
першого then повернути response.json(), який розпарсить ці дані
і перетворить їх у лдський формат. Після цього ще один then, для 
того щоб обробити проміс, який повернувся з першого then*/ 

// fetch("https://jsonplaceholder.typicode.com/todos")
//   .then((response) => {
//     return response.json();
//   })
//   .then((data) => {
//     console.log(data);
    
//   })

/*Спробуємо вивести результат, який ми отримаємо, на сторінку

Оскільки сервер може повернути помилку, 
то її потрібно обробити*/ 

// // 1. отримаємо доступ до елемента
// const list = document.querySelector(".todo-list");

// // 2. Відправимо запит на сервер і отримаємо дані
// fetch("https://jsonplaceholder.typicode.com/todos")
//   .then((response) => {
//     return response.json();
//   })
//   .then((data) => {
//     // 4. Відмалюємо список завдань
//     list.insertAdjacentHTML("beforeend", createMarkup(data));
//   })
//   .catch((error) => {
//     console.log(error);
//   })

// // 3. Напишемо функцію, яка створить розмітку
// function createMarkup(arr) {
//   return arr.map(({ id, title, completed }) => `
//     <li data-id="${id}" class="list-item">
//       <input type="checkbox" ${completed && "checked"}>
//       <p>${title}</p>
//     </li>
//   `).join("");
// }
/* ======================================================================================================================
обробка відповіді response (404 з fetch)
====================================================================================================================== */

/*Бувають випадки, що помилку викликає не запит на сервер,
певний код, який неправильно обробляє результат, що 
повертається з цього серверу, тоді ми взагалі не потрапимо
в блок catch. Ця ситуація може виникнути коли з серверу 
повертається результат 404 (Not Found). Чому? Тому що, 
для методу fetch 404 - це не помилка. Отже ми повинні руками
самостійно сказати в коді, що тут помилка. Як це зробити?
В першому then у обєкта response є властивість, яка вказує, що з 
сервера повернулися дані. Ця власвість називається ok, і 
якщо сервер повернув дані, то значенням цієї властивості 
буде true, якщо з сервера прийшла помилка - ok: false.
Якраз цією властивістю ми скористаємося, для того щоб 
відловлювати цю помилку і руками переводити наш код в 
блок catch. Для цього зробимо перевірку, де повинні за
певних умов, автоматично вручну викинути помилку 
throw new Error, після цього код автоматично перейде
в блок catch.
*/ 

// // 1. отримаємо досуп до елемента
// const list = document.querySelector(".todo-list");

// // 2. Відправимо запит на сервер і отримаємо дані
// fetch("https://jsonplaceholder.typicode.com/todos2")
//   .then((response) => {
//     // 5. Зробимо перевірку на 404
//     if (!response.ok) {
//       // 6. Створимо помилку
//       throw new Error("Ой лишенько!");
//     }
//     // Розпарсимо дані у потрібному форматі
//     return response.json();
//   })
//   .then((data) => {
//     console.log("then");
//     // 4. Відмалюємо список завдань
//     list.insertAdjacentHTML("beforeend", createMarkup(data));
//   })
//   .catch((error) => {
//     // 7. Відмалюємо помилку
//     list.insertAdjacentHTML("beforeend", `
//         <li>
//           <p>${error.message}</p>
//         </li>
//       `)
//   })

// // 3. Напишемо функцію, яка створить розмітку
// function createMarkup(arr) {
//   return arr.map(({ id, title, completed }) => `
//     <li data-id="${id}" class="list-item">
//       <input type="checkbox" ${completed && "checked"}>
//       <p>${title}</p>
//     </li>
//   `).join("");
// }

/* ======================================================================================================================

====================================================================================================================== */

/*Зараз ми отримали із сервера масив, який містить 
200 записів. Є можливість їх вісортувати і вказати, 
яку кількість ми хочемо отримати і відмалювати.
Для цього у нас є searchParams або queryParams, 
параметри нашого запиту. Для того, щоб ними 
скористатися потрібно зробти наступне
  1. в url після endpoint(в кінці адреси),
треба поставити ?, щоб відділити основну частину url
від searchParams
  2. далі вказати назви searchParams. У кожого сервера 
назва searchParams може бути своя. 
Це прописано у документації.Напр. _limit=10 
  3. Якщо потрібо передати декілька параметрів в url
їх потрібно розділити за допомогою знака &. Напишемо 
парамер _page=2, який візьме не перші 10 елементів, а 
наступні 10, починаючи з 11 елемента. Цей параметр дає 
змогу отримти не всю колекцію, а тільки певні 10 елементів.
  4. Таких параметрів може бути багато. За опомогою класів 
можна вирішити цю проблему. Створимо екземпляр класу 
URLSearchParams, в який як аргумент передамо обєкт, в якому
передамо параметри, які потрібно сформувати. За допомгою 
методу toString() можна перевірити в консолі, що він нам дає.
  5. І тепер ми можемо змінну params підставити в url. єдине 
залишаємо ? і використовуємо косі лапки для шаблонного рядка. 
*/ 

// const list = document.querySelector(".todo-list");

// // Створимо зміну, яка буде екземпляром класу URLSerchParams
// const params = new URLSearchParams({
//   _limit: 7,
//   _page: 2
// });

// console.log(params.toString());


// fetch(`https://jsonplaceholder.typicode.com/todos?${params}`)
//   .then((response) => {
//     if (!response.ok) {
//       throw new Error("Ой лишенько!");
//     }
//     return response.json();
//   })
//   .then((data) => {
//     console.log(data);
//     list.insertAdjacentHTML("beforeend", createMarkup(data));
//   })
//   .catch((error) => {
//     list.insertAdjacentHTML("beforeend", `
//         <li>
//           <p>${error.message}</p>
//         </li>
//       `)
//   })

// function createMarkup(arr) {
//   return arr.map(({ id, title, completed }) => `
//     <li data-id="${id}" class="list-item">
//       <input type="checkbox" ${completed && "checked"}>
//       <p>${title}</p>
//     </li>
//   `).join("");
// }


/* ======================================================================================================================
Всередині функції
====================================================================================================================== */

// function foo(url) {
//   return fetch(url)
//     .then(response => {
//       if (!response.ok) {
//         throw new Error(response.statusText);
//       }
//       return response.json();
//     })
// }

// foo("https://jsonplaceholder.typicode.com/users")
//   .then(data => console.log(data))
//   .catch(error => console.log("catch", error));