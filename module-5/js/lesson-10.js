"use strict";

// ========================================= 1

/**
 * Метод filter
 *
 * - Поелеметно перебирає оригінальний масив
 * - Повертає новий масив
 * (з елементами або порожній)
 * - Додає в масив, що повертається, елементи,
 * які задовольняють умову callback-функції
 *    - Якщо callback повернув true, елемент
 * додається в масив, що повертається
 *    - Якщо callback повернув false, елемент
 * НЕ додається в масив, що повертається
 */

/* 
Що робить метод filter?

Наш метод поелементно перебирає оригінальний
масив. При цьому повертає новий масив з 
елементами або порожній, тобто метод відноситься
до чистих функцій. Додає в масив, що повертається
елементи, які задовільняють умову callback
функції, тобто, якщо при перевірці елемента в 
умові перевірки з callback повернеться true,
то елемент додається до результуючого масиву, 
якщо callback повертає false - то не додається.
*/

// const numbers = [5, 10, 15, 20, 25];

// const filtered = numbers.filter((number, index, arr) => {});

/* 
Як це працює?

1. Метод filter повертає новий масив, тобто 
в місці, де ми його викличемо, буде 
підставлено новий масив. 
2. Ми цей масив збережемо у нову змінну.
3. Звертаємося до масива numbers і викликаємо
через крапку метод filter(). Це метод масиву
отже викликати його може тільки масив.
4. Метод приймає в себе callback-функцію, яка 
передана, в метод filter, під час його виклику,
як аргумент. 
5. Отже передаємо в метод callback функцію і 
пишемо її у форматі стрілочної. 
6. Далі в цю callback-функцію приходять 
наступні параметри:
    1. Це поточний елемент масиву(number), 
    назва якого довільна, оскількии це 
    параметр callback функції.
    2. Індекс(index) цього елемента масиву.
    3. Посилання на вихідний масив(arr), який 
    викликав цей метод.
Послідовність написання параметрів важлива.
Якщо не потрібні деякі параметри, то їх 
можна не записувати.
7. У тілі callback-функції буде записуватися 
умова(item < 15), яка перевірятиме елементи масиву, 
який перебирається, на істинність.
І якщо умова поверне true, то елемент, який
перевірявся додається до результуючого масиву, 
якщо false - то не додається.
8. Цей метод перебере вихідний масив з початку 
і до кінця, перевіряючи кожен елемент масиву, 
відповідно до умови перевірки, яка записана в
тілі callback-функції, і додаватиме або ні ці
елементи до нового результуючого масиву, при 
цьому не змінючи вихідний масив.  
9. Якщо callback буде одразу щось повертати,
то можна використати неявне повернення.
10. Якщо жоден з елементів не пройшов 
перевірку, то поверається порожній масив.
11. В рельтаті отримано новий масив 
filtered [5, 10].
12. При цьому вихідний масив залишився без 
змін numbers [5, 10, 15, 20, 25].
*/

// const numbers = [5, 10, 15, 20, 25];

// const filtered = numbers.filter((item) => item < 15);

// console.log(filtered);
// console.log(numbers);

// ---------------------------------------------------------

// const allCars = [
//     { make: "Honda", model: "CR-V", type: "suv", amount: 14, price: 24045, onSale: true},
//     { make: "Honda", model: "Accord", type: "sedan", amount: 2, price: 22455, onSale: true },
//     { make: "Mazda", model: "Mazda 6", type: "sedan", amount: 8, price: 24195, onSale: false },
//     { make: "Mazda", model: "CX-9", type: "suv", amount: 7, price: 31520, onSale: true },
//     { make: "Toyota", model: "4Runner", type: "suv", amount: 19, price: 34210, onSale: false },
//     { make: "Toyota", model: "Sequoia", type: "suv", amount: 16, price: 45560, onSale: false },
//     { make: "Toyota", model: "Tacoma", type: "truck", amount: 4, price: 24320, onSale: true },
//     { make: "Ford", model: "F-150", type: "truck", amount: 11, price: 27110, onSale: true },
//     { make: "Ford", model: "Fusion", type: "sedan", amount: 13, price: 22120, onSale: true },
//     { make: "Ford", model: "Explorer", type: "suv", amount: 6, price: 31660, onSale: false }
//   ];

/**
 * Нехай функція filterByPrice повертає масив
 * автомобілів, ціна яких менша, ніж значення
 * параметра threshold.
 */

// const filterByPrice = (cars, threshold) =>
//   cars.filter(car => car.price < threshold);

// console.table(filterByPrice(allCars, 27110));

// -------------------------------------------------

/**
 * Нехай функція getCarsWithType повертає масив
 * автомобілів, тип яких збігається зі значенням
 * параметра type.
 */

// const getCarsWithType = (arr, type) =>
//   arr.filter(item => item.type === type);

// console.table(getCarsWithType(allCars, "suv"));
// console.table(getCarsWithType(allCars, "truck"));
// console.log(getCarsWithType(allCars, "over"));

// =================================================== 2

/**
 * Метод find
 *
 * - Поелементно перебирає оригінальний
 * масив
 * - Повертає перший елемент, що задовільняє
 * умову перевірки або undefined, якщо не задовільняє
 */

/* 
Що робить метод find()?

Метод find так само поелементно
перебирає оригінальний масив, тобто 
це перебираючий метод масиву. При 
цьому повертає перший елемент, який 
задовільнить умову перевірки, яка 
записується у тілі callback-функції.
В протилежному випадку метод 
поверне undefined, якщо жоден з 
елементів масиву на задовільняє
умову.
*/

// const arr = [5, 10, 15, 20, 25];

// const number = arr.find((num, index, array) => {});

/* 
Як це працює?

1. Звертаємося до масиву з числами arr
і викликаємо в нього через крапку метод 
find(), тобто це метод масиву, отже 
викликати його може тільки масив. 
2. Цей метод приймає в себе callback-
функцію, яка передана, в метод find, 
під час його виклику, як аргумент. 
3. Отже передаємо в метод callback 
функцію і пишемо її у форматі стрілочної.
4. Ця стрілочна функція приймає в собі 
наступні параметри:
    1. Поточний елемент масиву (num)
    2. Індекс (index) цього елемента.
    3. Посилання на вихідний масив (array).
Послідовність написання параметрів важлива.
Якщо не потрібні деякі параметри, то їх 
можна не записувати.
5. У тілі callback записуємо умову
перевірки (num === 10).
6. Метод find працює дуже схожим чином, 
як метод filter().
7. Він також чекає поки callback йому 
поверне true. Але на відміну від filter, 
find чекає на перший true, який поверне
callback-функція.
8. Як тільки callback-функція повертає
true, то метод find поверне результат,
який влаштовує умову (num === 10), яка 
записана в callback-функції, і далі 
не працює, тобто припиняє 
перебирання масиву arr.
9. В результаті метод поверне перший
елемент, який пройшов перевірку умови, 
як записана у тілі callback-функції, 
число 15.
10. Фундаментальна різниця між методами
filter i find у тому, що filter поверне
масив елементів, які задовільняють умову, 
яка прописана у callback, а find поверне
лише перший елемент, який задовільняє умову, 
яка прописана у callback.
*/

// const arr = [5, 10, 15, 20, 25];

// const number = arr.find((num) => num > 10); // 15

// console.log(number); // 15

// -------------------------------------------------------

// const cars = [
//   { make: "Honda", model: "CR-V", type: "suv", amount: 14, price: 24045, onSale: true},
//   { make: "Honda", model: "Accord", type: "sedan", amount: 2, price: 22455, onSale: true },
//   { make: "Mazda", model: "Mazda 6", type: "sedan", amount: 8, price: 24195, onSale: false },
//   { make: "Mazda", model: "CX-9", type: "suv", amount: 7, price: 31520, onSale: true },
//   { make: "Toyota", model: "4Runner", type: "suv", amount: 19, price: 34210, onSale: false },
//   { make: "Toyota", model: "Sequoia", type: "suv", amount: 16, price: 45560, onSale: false },
//   { make: "Toyota", model: "Tacoma", type: "truck", amount: 4, price: 24320, onSale: true },
//   { make: "Ford", model: "F-150", type: "truck", amount: 11, price: 27110, onSale: true },
//   { make: "Ford", model: "Fusion", type: "sedan", amount: 13, price: 22120, onSale: true },
//   { make: "Ford", model: "Explorer", type: "suv", amount: 6, price: 31660, onSale: false }
// ];

/**
 * Шукаємо машину за моделлю
 */

// const findByModel = (arr, model) =>
//   arr.find((car) => car.model === model);

// console.log(findByModel(cars, "Accord"));
// console.log(findByModel(cars, "Sequoia"));
// console.log(findByModel(cars, "Explorer"));
// console.log(findByModel(cars, "Mersedes"));  // undefined

// -------------------------------------------

/**
 * Шукаємо машину за типом кузова
 */

/* 
Типів седан у нас декілька у масиві,
але метод find повернув перший елемент,
який задовільнив умову у callback-функції,
і припинив свою роботу, тобто далі метод 
не перебирає масив.
*/

// const findByType = (arr, type) => {
//   return arr.find(car => car.type === type);
// }

// console.log(findByType(cars, "sedan"));

// ======================================= 3

/**
 * Метод every
 *
 * - Поелементно перебирає оригінальний масив
 * - Повертає true, якщо всі елементи масиву
 * задовільняють умову
 */

/* 
Що робить метод every()?

Метод every - це перебираючий метод масиву,
який поелементно перебирає оригінальний масив, 
який викликав цей метод, і повертає true, якщо 
всі елементи масиву задовільняють умову, що 
прописана в callback-функції, яка була передана
методу every, як аргумент.
*/

// const players = [
// 	{ id: "player-1", name: "Mango", timePlayed: 310, points: 54, online: false },
// 	{ id: "player-2", name: "Poly", timePlayed: 470, points: 92, online: true },
// 	{ id: "player-3", name: "Kiwi", timePlayed: 230, points: 48, online: true },
// 	{ id: "player-4", name: "Ajax", timePlayed: 150, points: 71, online: false },
// 	{ id: "player-5", name: "Chelsy", timePlayed: 80, points: 48, online: true },
// ];

// const isAllOnline = players.every((player, index, arr) => player.online);

// console.log(isAllOnline); // false

/* 
Як це працює?

1. Звертаємося до масиву players і за 
допомогою крапки викликаємо метод every().
2. Цей метод приймає в себе callback-функцію,
яка передана, в метод every, 
під час його виклику, як аргумент. 
3. Передаємо в метод every callback 
функцію і пишемо її у форматі стрілочної.
4. Сallback приймає в себе наступні
параметри:
	1. Елемент (player) масиву, який перебирається.
	2. Індекс (index) цього елемента.
	3. Посилання на вихідний масив (arr). 
Послідовність написання параметрів важлива.
Якщо не потрібні деякі параметри, то їх 
можна не записувати. Назва параметрів довільна.
4. Наша callback-функція в методі every,
проводить перевірку (player.online), яка 
записана у тілі callback, кожного елемента 
масиву, який перебирається.
5. Якщо вона на кожній ітерації циклу умова
(player.online) поверне true, то метод every 
поверне true.
6. Якщо хоча б один елемент у перевірці поверне 
false, то метод every поверне false.
7. В результаті метод поверне false, оскільки
не у всіх елементів масиву в результаті
перевірки умови (player.online) у тілі callback
повернулося true. Тобто не кожен елемент масиву
задовільнив умову, яка прописана у callback.
*/

/**
 * Метод some
 *
 * - Поелементно перебирає оригінальний масив
 * - Повертає true, якщо хоча б один елемент
 * масиву задовільняє умову
 */

/*
Що робить метод some()?

Метод some поелементно перебирає оригінальний 
масив, але він поверне true, якщо хоча б 
один елемент масиву, в результаті перевірки умови, 
яка задана у тілі callback-функції, поверне true.
*/

// const players = [
// 	{ id: "player-1", name: "Mango", timePlayed: 310, points: 54, online: false },
// 	{ id: "player-2", name: "Poly", timePlayed: 470, points: 92, online: true },
// 	{ id: "player-3", name: "Kiwi", timePlayed: 230, points: 48, online: true },
// 	{ id: "player-4", name: "Ajax", timePlayed: 150, points: 71, online: false },
// 	{ id: "player-5", name: "Chelsy", timePlayed: 80, points: 48, online: true },
// ];

// const isAllOnline = players.some((player, index, arr) => player.online);

// console.log(isAllOnline); // true

/* 
Як це працює?

1. Звертаємося до масиву players і за 
допомогою крапки викликаємо метод some().
Метод масиву отже викликати цей метод
може тільки масив.
2. Цей метод приймає в себе callback-функцію,
яка передана, в метод some, 
під час його виклику, як аргумент. 
3. Передаємо в метод some callback 
функцію і пишемо її у форматі стрілочної.
4. Сallback приймає в себе наступні
параметри:
	1. Елемент (player) масиву, який перебирається.
	2. Індекс (index) цього елемента.
	3. Посилання на вихідний масив (arr). 
Послідовність написання параметрів важлива.
Якщо не потрібні деякі параметри, то їх 
можна не записувати. Назва параметрів довільна.
4. Наша callback-функція в методі some,
проводить перевірку (player.online), яка 
записана у тілі callback, кожного елемента 
масиву, який перебирається.
5 Якщо хоча б один елемент у перевірці поверне 
true, то метод some поверне true.
7. В результаті метод поверне true, оскільки
один з елементів масиву в результаті
перевірки умови (player.online) у тілі callback
повернув true.
*/

// =============================================== 4

/**
 * Метод reduce
 *
 * - Поелементно перебирає оригінальний масив.
 * - Значення, що повертаються, залежать
 * від розробника.
 */

/* 
Що робить метод reduce()?

Метод reduce поелементно перебирає
оригінальний масив, значення, що 
повертається залежать від розробника 
*/

// const numbers = [1, 10, 20, 30, 40];

// const total = numbers.reduce((acc, item, index, arr) => {}, 0)

/* 
Як це працює?

1. Створюємо масив numbers.
2. Створимо змінну total, в якій збережемо 
результат виклику методу reduce масивом
numbers.
3. Цей метод частіше за все використовують,
щоб порахувати суму всіх елементів, тому що
з його допомогою можна уникнути створення
додаткових проміжних змінних, а зробити все
одразу в callback-функції, яку в себе 
приймає reduce, як аргумент.
4. Передаємо в метод reduce callback 
функцію і пишемо її у форматі стрілочної.
5. Сallback приймає в себе наступні
параметри:
	1. Акумулятор (acc) - це проміжна змінна, в 
	яку зберігається проміжний результат
	виконання callback-функції.
	2. Поточний елемент масиву (item), 
	який перебирається.
	3. Індекс (index) поточного елементу.
	4. Посилання на вихідний масив. 
Послідовність написання параметрів важлива.
Якщо не потрібні деякі параметри, то їх 
можна не записувати. Назва параметрів довільна.
6. Ще опційно, тобто необовязково, метод
reduce може прймати другий аргумент.
7. Другий аргумент це початкове значення
акумулятора. Наразі початкове значення 
акумулятора дорівнює 0. Тобто на першій 
ітерації циклу, значення акумулятора 
буде дорівнювати 0.
8. Якщо початкове значення акумулятора не 
передати, то ним стане перший елемент
масиву, який викликав метод reduce.
Якщо не вказати, то цикл одразу перейде
до другої ітерації.
З цим треба уважно.
9. Пишемо з явним поверненням.
10. Що ми буде повертатися з callback-
функції, яка знаходиться в методі reduce?
11. На кожній ітерації циклу, з callback-
функції має обовязково повертатися 
наступне актульне значення акумулятора.
12. Тобто має повернутися акумулятор + 
елемент масиву (return acc + item).
*/

// const numbers = [1, 10, 20, 30, 40];
// //														0			1
// const total = numbers.reduce((acc, item) => {
// //         0 +   1
// 	return acc + item; // 1
// }, 0);

// const total = numbers.reduce((acc, item) => acc + item, 0);

// console.log(total); // 101

/*
Давайте розбиратися.

1. На першій ітерації reduce починає
перебирати масив.
2. Нуль це буде початкове значення акумулятора
на першій ітерації циклу, оскільки ми 
самостійно це вказали в другому аргументі, 
коли масив numbers викликав метод reduce. 
3. Далі item це перший елемент масиву, який 
дорівнює 1.
4. Заходимо в тіло callback, в якому ми 
додаємо значення акумулятора (0) до елемента
масиву (1) і повертає цю суму(1), яка потрапляє 
в акумулятор.
5. Далі ця сума стає новим значенням акумулятора, 
яке буде використовуватися на наступній ітерації
циклу.
6. Кінець першої ітерації.
7. На другій ітерції значення акумулятора вже 1.
8. Значення елемента масиву буде 10.
9. Заходимо в тіло callback, в якому ми 
додаємо значення акумулятора (1) до елемента
масиву (10) і повертає цю суму(11), яка потрапляє 
в акумулятор.
10. Далі ця сума (11) стає новим значенням акумулятора, 
яке буде використовуватися на наступній ітерації
циклу.
11. Кінець другої ітерації. 
12. І так далі, поки метод не перебере весь масив.
13. Результатом виконання методу буде сума всіх
елементів масиву, яке збережене у total (101).
14. Оскільки у методі виконується лише одна
дія, то можна скористатися неявним поверненям.
*/

/*
Висновки

1. У методі reduce на кожній ітерації callback-функція
буде щось повертати. І це щось буде збережено в 
акумулятор для використання на наступній ітерації.
2. Як правило метод reduce використовуть для чисел, 
але можливі і інші варіанти.
*/

// ------------------------------------------------

/**
 * Рахуємо загальну зарплату
 */

// const salary = {
// 	mango: 100,
// 	poly: 50,
// 	ajax: 150,
// };

// const totalSalary =
// 	Object.values(salary).reduce((acc, num) => acc + num, 0);

// console.log(totalSalary);

// -----------------------------------------------------

/**
 * Рахуємо загальну кількість годин
 */

/*
У цьому випадку потрібно задавати
початкове значення акумулятору, яке 
задається у методі reduce другим
аргументом. Якщо цього не зробити, то
початковим значенням акумулятора стане
перший елемент масиву, тобто у нашому
випадку це обєкт.
*/

// const players = [
// 	{ id: "player-1", name: "Mango", timePlayed: 310, points: 54, online: false },
// 	{ id: "player-2", name: "Poly", timePlayed: 470, points: 92, online: true },
// 	{ id: "player-3", name: "Kiwi", timePlayed: 230, points: 48, online: true },
// 	{ id: "player-4", name: "Ajax", timePlayed: 150, points: 71, online: false },
// 	{ id: "player-5", name: "Chelsy", timePlayed: 80, points: 48, online: true },
// ];

// const total =
// 	players.reduce((acc, player) => acc + player.timePlayed, 0);

// console.log(total); // 1240

// ----------------------------------------------

/**
 * Рахуємо загальну суму товарів кошика
//  */

// const cart = [
//   { label: "Apples", price: 100, quantity: 2 },
//   { label: "Bananas", price: 120, quantity: 3 },
//   { label: "Lemons", price: 70, quantity: 4 },
// ];

// const total = cart.reduce((acc, item) => {
// 	return acc + item.price * item.quantity;
// }, 0)

// console.log(total); // 840

// ================================================ 5

/**
 * Метод toSorted
 *
 * - Свій порядок сортування чисел
 * - Свій порядок сортування рядків
 * - Сортування обєктів
 *
 * За замовчуванням:
 * - сортує за зростанням
 * - приводить елементи до рядка і
 * сортує за Unicode
 * - не змінює вихідний масив
 */

/*
Що робить метод toSorted()?

Метод toSorted існує для того, щоб
сортувати значення в масиві.
*/

// const numbers = [1, 9, 6, 2, 3];

// const sorted = numbers.toSorted();

// console.log(sorted);

/* 
Як це працює? 

1. Створимо зміну numbers, в якій
буде зберігатися масив чисел.
2. Створимо зміну sorted, де 
звертаємося до масива numbers і 
викликаємо в нього метод toSorted.
3. За замовчуванням цей метод сортує 
елементи в масиві, як рядки, тобто
він приводить елементи масиву до 
рядків і сортує їх за unicode.
4. За unicode літери у верхньому 
регістрі мають менше значення, 
ніж літери у нижньому.
5. Для того, щоб сортування було
більш-менш людським, потрібно в 
метод toSorted передати callback-
функцію, як аргумент, у форматі
стрілочної.
6. Ця callback-функція приймає в себе
два параметри, які мають довільну назву.
7. Ці параметри на кожній ітерації будуть
двома елементами з мого масиву(a, b).
8. Звертаємося до першого елемента (а) і
викликаємо в нього метод localeCompare().
9. В цей метод, як аргумент передаємо 
другий елемент (b).
10. Метод localeCompare відсортує 
масив рядків.
11. Також можливе сортування у зворотньому
порядку, для цього потрібно елементи поміняти 
місцями у тілі callback.
*/

// const array = ["b", "B", "a", "A"];

// console.log(array.toSorted());
// console.log(array.toSorted((a, b) =>a.localeCompare(b)));

// -------------------------------------------------------

/**
 * compareFunction - функція порівняння (callback)
 * Елементи масиву сортуються відповідно до її
 * значення, що повертається
 */

// const numbers = [1, 9, 6, 12, 3];

// console.log(numbers.toSorted((a, b) => a - b));
// // [1, 3, 6, 9, 12] зростання
// console.log(numbers.toSorted((a, b) => b - a));
// // [12, 9, 6, 3, 1] спадання

/* 
1. Коли будуть сортуватися числа, 
то може виникнути проблема в тому, 
метод сортує за юнікодом і в чисел 
буде порівнюватися лише перший елемент.
2. Для виправлення цього потрібно методу
передати callback, як аргумент.
3. Ця callback-функція приймає в себе
два параметри, які мають довільну назву.
Нехай буде (a, b).
4. Якщо потрібно математично відсортувати
масив від початку до кінця треба в тілі
callback-функції прописати a - b, тобто від 
першого елемента відняти другий елемент, якщо 
потрібно у форматі зростання. Для формату 
спадання навпаки b - а.
*/

// -----------------------------------------

/**
 * Сортуваня масиву обєктів
 */

// const players = [
// 	{ id: "player-1", name: "Mango", timePlayed: 310, points: 54, online: false },
// 	{ id: "player-2", name: "Poly", timePlayed: 470, points: 92, online: true },
// 	{ id: "player-3", name: "Kiwi", timePlayed: 230, points: 48, online: true },
// 	{ id: "player-4", name: "Ajax", timePlayed: 150, points: 71, online: false },
// 	{ id: "player-5", name: "Chelsy", timePlayed: 80, points: 48, online: true },
// ];

// За ігровим часом

// const sortedByTime =
// 	players.toSorted((a, b) => a.timePlayed - b.timePlayed);

// console.table(sortedByTime);

// ---------------------------------------------------------

// =========================================== 6

/**
 * Ланцюжки методів
 */

/* 
За допомогою ланцюжка методів не 
потрібно створювати додаткові
змінні, в яких будуть зберігатися 
проміжні результати, а одразу 
викликати методи один за одним, 
тим самим утворювати ланцюжок з 
методів. Для кращої читабельності 
ланцюжок потрібно відформатувати.
*/

/*
Ланцюжок методів може бути 
довільної довжини, але 
зазвичай не більше 2-3 операцій.

По-перше, перебираючі методи 
використовуються для порівняно 
простих операцій над колекцією. 
По-друге, виклик кожного наступного 
методу — це додаткове перебирання 
масиву, що за великої кількості 
може позначитися на продуктивності.
*/

// const numbers = [1, 5, 3, 2, 4];

// 1 спосіб
// const arr = numbers.filter(num => num > 2);
// const arr1 = arr.map(num => num * 3);
// const arr2 = arr1.toSorted((a, b) => a - b);

// 2 спосіб - практичний
// const result = numbers
// 	.filter((num) => num > 2) // [5, 3, 4]
// 	.map((num) => num * 3) // [15, 9, 12].toSorted
// 	.toSorted((a, b) => a - b); // [9, 12, 15]

// console.log(result);

// --------------------------------------

// const allCars = [
//   { make: "Honda", model: "CR-V", type: "suv", amount: 14, price: 24045, onSale: true},
//   { make: "Honda", model: "Accord", type: "sedan", amount: 2, price: 22455, onSale: true },
//   { make: "Mazda", model: "Mazda 6", type: "sedan", amount: 8, price: 24195, onSale: false },
//   { make: "Mazda", model: "CX-9", type: "suv", amount: 7, price: 31520, onSale: true },
//   { make: "Toyota", model: "4Runner", type: "suv", amount: 19, price: 34210, onSale: false },
//   { make: "Toyota", model: "Sequoia", type: "suv", amount: 16, price: 45560, onSale: false },
//   { make: "Toyota", model: "Tacoma", type: "truck", amount: 4, price: 24320, onSale: true },
//   { make: "Ford", model: "F-150", type: "truck", amount: 11, price: 27110, onSale: true },
//   { make: "Ford", model: "Fusion", type: "sedan", amount: 13, price: 22120, onSale: true },
//   { make: "Ford", model: "Explorer", type: "suv", amount: 6, price: 31660, onSale: false }
// ];

/**
 * Нехай функція getModelsOnSale повертає масив моделей
 * автомобілів, але тільки тих, які зараз на розпродажі.
 */

// const getModelsOnSale = cars => {
// 	return cars
// 	.filter(car => car.onSale)
// 	.map(car => car.model)
// };

// console.log(getModelsOnSale(allCars));

// -------------------------------------------------------

/**
 * Нехай функція getSortedCarsOnSale повертає
 * масив автомобілів на розпродажі
 * (Властивість onSale), відсортованих за зростанням ціни.
 */

// const getSortedCarsOnSale = (cars) => {
// 	return cars
// 		.filter(car => car.onSale)
// 		.toSorted((a, b) => a.price - b.price)
// };

// console.table(getSortedCarsOnSale(allCars));

// -----------------------------------------------------------

/*
Метод indexOf поверне індекс першого
елемента, який він знайде в масиві.
*/

// const students = [
//   { name: "Mango", score: 83, courses: ["mathematics", "physics"] },
//   { name: "Poly", score: 59, courses: ["science", "mathematics"] },
//   { name: "Ajax", score: 37, courses: ["physics", "biology"] },
//   { name: "Kiwi", score: 94, courses: ["literature", "science"] },
// ];

// const uniqueSortedCourses = students
//   .flatMap(student => student.courses)
//   .filter((course, index, array) => array.indexOf(course) === index)
//   .toSorted((a, b) => a.localeCompare(b));

// console.log(uniqueSortedCourses);
// // ["biology", "science", "literature", "mathematics", "physics"]

// ----------------------------------------------------------

// const arr = ["apple,🍎", "orange,🍑", "banana,🍌", "lemon,🍋"];

// const obj = arr.reduce((acc, item) => {
// 	const itemArr = item.split(",");
// 	// const key = itemArr[0];
// 	// const value = itemArr[1];

// 	acc[itemArr[0]] = itemArr[1];
// 	return acc;

// }, {});

// console.log(obj);

/** */
/* */
