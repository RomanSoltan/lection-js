// =================================== 1

/**
 * Методи рядків
 *
 * - slice
 * - toLowerCase/toUpperCase
 * - includes
 * - startsWith/endsWith
 * - indexOf
 * - trim
 */

// Приклад з поясненням вийнятку у порівнянні

// console.log(null > 0); // null перетвориться на числовий тип данних і повернеться false
// console.log(null < 0); // false

// console.log(null == 0); // поверне false, тому що в документації ECMA Script є алгоритми порівняння, і саме це порівняння буде вийнятком, який не підходить під жоден з алгоритмів і його потрібно запамятати.

// console.log(null >= 0); // поверне true. зламай собі мозок!!!!
// console.log(null >= 0); // поверне true. зламай собі мозок!!!!

/**
 * Методи рядків
 */

// Методи рядків - по факту це функції, які дають можливість нам дуже простим чином якось взаємодіяти з нашими рядочками. Тобто це методи лише для РЯДКІВ і ми можемо викликати ці методи тільки у рядків.

// 1. Метод slice()

// string.slice(startIndex, endIndex) // синтаксис

// Метод slice() вирізає з рядочку, і створює підрядок, в який записує копію рядка. Він дозволяє витягувати підрядок з вихідного рядка, вказуючи початковий та кінцевий індекси.

// Метод slice() опційно може приймати в себе два аргументи
// Перший аргумент - це індекс елемента, з якого ми починаємо вирізати наш підрядок з рядка.
// Другий аргумент - це індекс елементу, до якого потрібно вирізати наш підрядок, не включаючи цей елемент в підрядок. Другий аргумент можна не передавати, в такому разі slice() виріже підрядок, починаючи від першого аргумента і до самого кінця.
// Якщо не передати жодного аргумента, то метод slice() просто скопіює рядок без змін.
// Можна передавти і від'ємні індекси, щоб починати вирізати підрядок з кінця рядку.

// const user = "Alice Franko";

// const str = user.slice(0, 3); //    012  3 - не включається
// console.log("str", str); // поверне новий підрядок "Ali"
// console.log("user", user); // поверне рядок "Alice Franko", який залишився незмінним

// 2. Метод toLowerCase/toUpperCase

// Синтаксис
// string.toLowerCase();
// string.toUpperCase();

// Метод toLowerCase() приведе всі символи рядка в нижній регістр і поверне новий підрядок, не змінючи рядок, над яким виконується цей метод.

// const user = "Alice Franko";

// console.log(user.toLowerCase()); // поверне рядок "Alice Franko" у нижньому регістрі "alice franko"
// console.log(user); // поверне рядок "Alice Franko"

// Метод toUpperCase() приведе всі символи рядка до верхнього регістру і поверне новий підрядок, не змінючи рядок, над яким виконується цей метод.

// const user = "Alice Franko";

// console.log(user.toUpperCase()); // поверне рядок "Alice Franko" у верхньому регістрі "ALICE FRANKO"
// console.log(user); // поверне рядок "Alice Franko"

// 3. Метод includes()

// Синтаксис
// string.includes(аргумент);

// Метод includes() перевіряє чи є в рядку, який викликав цей метод, підрядок, котрий метод includes() отримав як аргумент. Тобто ми питаємо: чи є?, чи немає? такого символу у рядку, а метод нам відповідає: є(true) або немає (false).
// Повертає булеве значення true або false.
// Чутливий до регістру. "А" і "а" - це різні символи.
// Якщо не передати жодних аргументів повернеться false.
// Порожній рядок ("") повертає true

// const user = "Alice Franko";

// console.log(user.includes("lic")); // поверне true. Оскільки така послідовність символів є у змінній user.

// 4. Метод startsWith() / endsWith().

// Синтаксис
// string.startsWith(аргумент);
// string.endsWith(аргумент);

// Метод startsWith() перевіряє чи рядок, який викликав цей метод, починається на підрядок, який був отриманий методом startsWith() як аргумент.
// Метод endsWith() перевіряє чи рядок, який викликав цей метод, закінчується на підрядок, який був отриманий методом endsWith() як аргумент.
// Повертає булеве значення true або false.
// Чутливий до регістру. "А" і "а" - це різні символи.
// Якщо не передати жодних аргументів повернеться false.
// Порожній рядок ("") повертає true

// const user = "Alice Franko";

// console.log(user.startsWith("Ali")); // поверне true. Оскільки рядок почиається з символів "Ali"
// console.log(user.endsWith("Ali")); // поверне false. Оскільки рядок не закінчується символами "Ali".

// 5. Метод indexOf()

// Синтаксис
// string.indexOf(аргумент);

// Аргументом передається символ, який будуть шукати у рядку

// Метод indexOf() перевіряє чи знаходиться у рядку, який викликав цей метод, символ, переданий аргументом у методі.
// Повертає індекс символа.
// Якщо символ відсутній - повертає -1.
// Чутливий до регістру. "А" і "а" - це різні символи.
// Якщо не передати жодних аргументів повернеться -1.
// Порожній рядок ("") повертає 0.
// Якщо у рядку є декілька однакових символів, то повернеться індекс першого символу, який метод знайде.

// const user = "Alice Franko";

// console.log(user.indexOf("a")); // поверне 8. індекс символа "а".
// console.log(user.indexOf("f")); // поверне -1. символ відсутній.
// console.log(user.indexOf("")); // поверне 0.

// 7. Метод trim()

// Синтаксис
// string.trim();

// Метод trim() прибирає зайві пробіли на початку і в кінці рядка.
// Цей метод використовуєтьс для передбачення непередбаченої поведінки користувача, коли останній поставив зайві пробіли на початку і в кінці рядка при введенні певної інформації, наприклад в інпут.

// const user = "          Alice Franko             ";

// console.log(user);
// console.log(user.trim());

// =================================== 2

/**
 * Форматування посилання
 *
 * Напиши скрипт, який перевіряє чи закінчується значення
 * змінної link символом /. Якщо ні, додай до кінця
 * значення link цей символ.
 * Використовуй конструкцію if...else
 */

// let link = "https://my-site.com/about";
// //перевірка чи є / у кінці рядка.
// // якщо буде - / не додається
// // якщо нема, то додати / до рядка.
// // ! false перетворює в true, щоб потрапити в блок if.
// // Коректне опрацювання False - значень
// if (!link.endsWith("/")) {
//   link += "/"; // додаємо / до рядка (конкатенація)
// }
// console.log(link);

/**
 * Напиши скрипт який перевіряє чи закінчується значення
 * змінної link символом /. Якщо ні, додай до кінця
 * значення link цей символ, але тільки в тому випадку,
 * якщо в link є підрядок "my-site".
 * Використовуй конструкцію if...else або тернарний оператор
 */

// let link = "https://my-site.com/about";

// if (!link.endsWith("/") && link.includes("my-site")) {
//   link += "/";
// }
// console.log(link);

// тернарний оператор

// console.log(
//   !link.endsWith("/") && link.includes("my-site") ? (link += "/") : link
// );

/**
 * Пошук у рядку методом includes()
 */

// const blacklistedWord1 = "spam";
// const blacklistedWord2 = "sale";

// const string1 =
//   "Hello, I'm Prince Abdul, this is not spam, I'm offering you a mil";
// const string2 = "Biggest SALE this week, don't miss out!";
// const string3 = "#fatlivesmatter advertising campaign";

// console.log(string1.includes(blacklistedWord1)); // true
// console.log(string1.includes(blacklistedWord2)); // false

// console.log(string2.includes(blacklistedWord1)); // false
// console.log(string2.includes(blacklistedWord2)); // false

// Потрібно передбачити поведінку користувача і нормалізувати рядок, який користувач надсилає. Оскільки повідомлення може бути написане в різних регістрах, тому доцільно нормалізувати саме інфу від користувача і приводити її до нижнього регістру для коректної перевірки.

// const normStr = string2.toLowerCase();
// console.log(normStr.includes(blacklistedWord2)); // true

// console.log(string3.includes(blacklistedWord1)); // false
// console.log(string3.includes(blacklistedWord2)); // false

// =================================== 3

/**
 * Цикли
 *
 * - Цикл for
 * - Відлік від 0 до N
 * - Зворотній відлік від N до 0
 * - Збільшення/зменшення лічильника на 2+
 * - Інкремент і декремент
 * - Цикл while і do...while
 */

/**
 * ================== Цикл for
 */

// Синтаксис циклу for

// for (ініціалізація; умова; пост-вираз) {
//тіло циклу
// }

// Ініціалізація (initialization) - створюється змінна-лічильник, якій присвоюється значення. Зміну прийнято називати i(index). Ініціалізація виконується один раз перед початком циклу.

// Умова (conditon) - створюється умова (так звана умова виходу), до якої буде працювати цикл, тобто поки умова буде true. Це вираз, який оцінюється перед кожною ітерацією (повторенням) циклу. Ітерація - це одне пробігання нашого циклу.

// Пост-вираз (afterthought) - це вираз, який виконується в кінці кожної ітерації циклу, перед перевіркою умови. Використовується для оновлення значення змінної-лічильника.

// Тіло циклу (statement) - це блок коду, який буде виконуватися на кожній ітерації циклу, якщо умова перетворюється на true.

// Поки працює цикл - код далі не піде і чекатиме на його завершення. Спочатку цикл має відпрацювати і припинити свою роботу. Лише після цього починає відпрацьовувати код після циклу.

//Як насправді цикл працює
// 1. Створюється цикл
// 2. В циклі, за допомогою ключового слова let (const видасть помилку) оголошується змінна і(index), якій присвоюється значення нуля(або інше, в залежності від умови).
// 3. Після цього ця змінна і(index) буде перевірятися в умові, яка задана в циклі.
// 4. Якщо вираз в умові повертає true - це означає, що ми потрапляємо в тіло циклу та виконуємо код, який там написаний.
// 5. Після виконання коду ми виходимо з тіла циклу та потрапляємо в пост-вираз, де змінна і(index) збільшується/зменшується на одиницю(або інше значення, яке записане у пост-виразі).
// 6. Після цього, ми повертаємося до умови та здійснюємо перевірку виразу з оновленим значенням змінної і(index).
// 7. Якщо результатом виразу буде true, то ми потрапляємо до тіла циклу та виконуємо код, який там записаний. І так по колу, поки вираз в умові не поверне false. Якщо не поверне false, то відбудеться зациклення і цикл буде виконуватися безкінечно. Тому цього потрібно уникати, і подбати про те, щоб була умова виходу з циклу, яка приводила до false.
// 8. Якщо результатом виразу буде false, то ми припиняємо виконання циклу і виходимо з нього.

// console.log("before");

// for (let i = 0; i < 10; i += 1) {
//   console.log(i);
// }

// console.log("after");

// for (let i = 10; i >= 0; i -= 1) {
//   console.log(i);
// }

// // порахувати суму чисел від 1 до 3
// let sum = 0;
// for (let i = 1; i <= 3; i += 1) {
//   sum += i;
// }
// console.log(sum);

// // Вивести символи рядка в консоль з допомогою їх індексів
// const str = "Hello";

// for (let i = 0; i < str.length; i += 1) {
//   console.log(i, str[i]);
// }

// const index = 2;
// console.log(str[index]);

/**
 * ============== Інкремент
 */

// Синтаксис

// Інкремент - це синтаксис, який дозволяє нам збільшувати(інкремент) значення нашого числа на одиницю.

// Декремент - це синтаксис, який дозволяє зменшувати(декремент) значення числа на одиницю.

// Є префіксний і постфіксний декремент та інкремент.

// Префіксний інкремент
// Синтаксис
// ++a

// Якщо ми використовуємо префіксний інкремент (++а) це означає наступне, що спочатку відбудеться збільшення значення нашої змінної (a) на одиницю, а вже після цього я кажу (b) приймає значення (a)
// Спочатку відбувається дія додавання, а потім вже актуалізоване значення приймає участь у нашому обчисленні

// let a = 10;
// const b = ++a; // 10 + 1 ...... a = b

// console.log("a", a); // 11
// console.log("b", b); // 11

// Постфіксний інкремент
// Синтаксис
// a++

// Якщо ми використовуємо постфіксний інкремент (а++) це означає наступне, що спочатку ми в нашу змінну (b) присвоємо поточне значення змінної (a), вже після цього відбудеться збільшення значення нашої змінної (а) на одиницю.
// Спочатку поточне значення змінної (а) приймає участь у виразі, після цього значення змінної (а) збільшується на одиницю.
// Використовується, щоб збільшувати значення змінної-лічильника у пост-виразі циклу.

// let a = 10;
// const b = a++; // b = 10 ...... a + 1

// console.log("a", a); // 11
// console.log("b", b); // 10

// Префіксний декремент
// Синтаксис
// --a

// let a = 10;
// const b = --a; // 10 - 1 .... b = 9 змінна b отримала актуалізовне значення

// Відбувається те саме, що з інкрементом, тільки замість додавання буде віднімання

// console.log("a", a); // 9
// console.log("b", b); // 9

// Постфіксний декремент
// Синтаксис
// a--

// Відбувається те саме, що з інкрементом, тільки замість додавання буде віднімання

// Спочатку в змінну (b) присвоюється поточне значення змінної (a), а потім вже виконає дію віднімання одинички.

// let a = 10;
// const b = a--; // b = 10 ...... a - 1

// console.log("a", a); // 9
// console.log("b", b); // 10

// Де використовується
// for (let i = 0; i < 5; i++) {

// }

// ========================== while

// Синтаксис

// let counter = 0;
// while (умова) {
// тіло циклу
// counter += 1;
// }

// Цикл while спочатку перевіряє умову, а потім вже виконує дію. Якщо умова одразу хибна, то цикл не буде виконуватися і ми не порапимо в тіло нашого циклу while взагалі.

// Для того, щоб прописати умову виходу з циклу, перед його створенням оголошується змінна(counter), за допомогою ключового слова let, у глобальній області видимості, значення якої і буде перевірятися в умові.

// Умова - це умова виходу з циклу. Тобто коли умова перевірки поверне false, то цикл припиняє свою роботу і відбувається вихід з циклу

// Обов'язково ми повинні збільшувати(зменшувати) у тілі циклу нашу змінну(counter) для того, щоб наша умова виходу, в якийсь момент стала хибною(false) і ми припинили виконання циклу.
// В іншому випадку відбудеться зациклення.

// Різниця між циклами for i while у тому, що змінна-лічильник у for оголошується у циклі і живе тільки у області видимості цього циклу, а у while - оголошується за межами циклу у глобальній області видимості. У while немає пост-виразу і збільшувати змінну-лічильник потрібно у тілі самого циклу, коли у for зміна збільшується у пост-виразі.

// console.log("before");

// let counter = 0;

// while (counter < 10) {
//   console.log(counter);
//   counter += 1;
// }

// console.log("after");

// Задача на знаходження суми чисел від 0 до 3
// let counter = 0;
// let sum = 0;

// while (counter <= 3) {
//   sum += counter;
//   counter++;
// }

// console.log(sum);

// ========================== do... while

// Синтаксис

// let counter = 0;

// do {
// // тіло циклу
//   counter++;
// } while (умова виходу);

// Оголошується глобальна змінна (counter) за межами циклу.
// Спочатку пишеться ключове слово do, після нього відкриваються фігурні дужки, в яких прописується тіло циклу, тобто код, який буде відпрацьовувати.
// В тілі циклу обовязково прописується збільшення(зменшення) нашої змінної-лічильника(counter).
// Після пишеться ключове слово while, відкриваюься круглі дужки і всередині цих дужок прописуєься умова виходу з циклу.
// Цикл do... while як мінімум один раз відпрацює, навіть якщо умова виходу одразу поверне false на першій ітерації циклу. Оскільки спочатку вконається тіло циклу, а потім відбудеться перевірка умови виходу.
// Ось така особливість.

// let counter = 0;

// do {
//   console.log(counter);
//   counter++;
// } while (counter <= 3);

// =================================== 3

/**
 * Напиши цикл for, який виводить у консоль браузера
 * числа за зростанням від a до b,
 * але тільки якщо число кратне 5.
 */

// const a = 20;
// const b = 100;

// for (let i = a; i <= b; i++) {
//   if (!(i % 5)) {
//     console.log(i);
//   }
// }

/**
 * Напиши скрипт, який підраховує суму всіх парних чисел,
 * які входять в діапазон чисел у змінних від min до max.
 * Наприклад, якщо min = 0 і max = 5, то діапазон 0-5, і в
 * ньому два парних числа - 2 і 4, їх сума 6.
 */

// const min = 0;
// const max = 5;

// function foo(x, y) {
//   let sum = 0;

//   for (let i = min; i <= max; i++) {
//     if (!(i % 2)) {
//       sum += i;
//     }
//   }
//   return sum;
// }

// console.log(foo(min, max));

//======================== Ключове слово break

// Ключове слово break перериває виконання циклу і передається керування на наступну інструкцію за циклом, але не зупиняє виконання функції

// const a = "orld";

// for (let i = 0; i < a.length; i++) {
//   if (a[i] === "r") {
//     break;
//   }
//   console.log(a[i]);
// }

//Що тут відбувається?
// 1. Отримаємо значення 0 зі змінної (і).
// 2. Відбувається перевірка виразу в умові виходу з циклу. Питається 0 < 4(довжина нашого рядка)? Так. Повертається true.
// 3. Отже ми потрапляємо в тіло циклу for, де виконується код циклу.
// 4. В тілі циклу ми натрапляємо на блок if.
// 5. Для того щоб потрапити в блок if потрібно, щоб перевірка умови повернула true.
// 6. В умові питається чи символ під ідексом 0 === "r"?
// 7. Ні, не дорівнює. Отже вираз повертає false.
// 8. Це означає, що ми не потрапляємо у наш блок if.
// 9. Після цього в консолі виводиться значення символу під індексом 0.
// 10. Далі ми переходимо до пост-виразу циклу, де оновлюється значення нашої змінної-лічильника. В нашому випадку значення збільшується на 1.
// 11. Кінець першої ітерації.
// 12. Далі розпочинається друга ітерація.
// 13. Ми знову звертаємося до умови виходу з циклу, де відбувається перевірка виразу. 1 < 4 Так. повертається true.
// 14. Потрапляємо в тіло циклу for.
// 15. Відбувається перевірка для того, щоб потрапити в блок if
// 16. Для того щоб потрапити в блок if потрібно, щоб перевірка умови повернула true.
// 17. В умові питається чи символ під індексом 1 === "r"?
// 18. Так, дорівнює. Повертається true
// 19. Отже ми потрапляємо в блок if, де виконується код цього блоку.
// 20. В блоці if ми натрапляємо ключове слово break, яке одразу припиняє виконання мого циклу.
// 21. В результаті в консолі браузера, ми побачимо лише один символ "r",
// 22. Хоча наш цикл мав перебрати усі символи рядка, але ключове слово break завчасно зупинило виконання циклу.

//======================== Ключове слово continue

// Ключове слово continue одразу припиняє виконання циклу з наданим значенням зі змінної-лічильника, і одразу переводить виконання циклу до пост-виразу, де оновлюється змінна-лічильник на одиницю і закінчується ітерація.
// Далі розпочинається наступна ітерація.

// Непарні числа

// const min = 0;
// const max = 5;
// let sum = 0;

// for (let i = min; i <= max; i++) {
//   if (i % 2 !== 0) {
//     continue;
//   }
//   sum += i;
// }
// console.log(sum);

// // Повернеться нуль
// const min = 0;
// const max = 5;
// let sum = 0;

// for (let i = min; i <= max; i++) {
//   if (i % 2 !== 0) {
//     break; // break зупинить виконання циклу
//   }
//   console.log(i); // буде 0
// }

// function findNumber(start, end, divisor) {
//   for (let i = start; i <= end; i++) {
//     if (!(i % divisor)) {
//       return i;
//     }
//   }
// }
// console.log(findNumber(2, 6, 5));

/**
 * Функція calculateTotal(number) приймає ціле число (параметр number).
 *  Доповни код функції так, щоб вона повертала суму всіх цілих чисел
 * від одиниці до цього числа включно. Наприклад, якщо number дорівнює
 *  3, то сума - це 1 + 2 + 3, тобто 6.
 */

// function calculateTotal(number) {
//   let sum = 0;
//   for (let i = 1; i <= number; i++) {
//     sum += i;
//   }
//   return sum;
// }

// console.log(calculateTotal(18));

/**
 * Функція checkFileExtension(fileName, ext) приймає два параметри:
 * fileName - рядок, що зберігає ім'я файлу з розширенням, наприклад,
 *  styles.css, hello.js тощо.
 * ext - рядок, що зберігає розширення, наприклад, .css, .js тощо
 *
 * Доповни код функції так, щоб:
 * Якщо ім'я файлу fileName закінчується розширенням, зазначеним у
 * параметрі ext, то функція повертала рядок "File extension matches"
 * В іншому разі, функція повертала рядок
 * "File extension does not match"
 */

// endsWith() if..else

// function checkFileExtension(fileName, ext) {
//   if (fileName.endsWith(ext)) {
//     return "File extension matches";
//   } else {
//     return "File extension does not match";
//   }
// }
// console.log(checkFileExtension("styles.css", ".js"));

// Тернарий

// function checkFileExtension(fileName, ext) {
//   const matchExt = fileName.endsWith(ext)
//     ? "File extension matches"
//     : "File extension does not match";
//   return matchExt;
// }
// console.log(checkFileExtension("styles.css", ".css"));

// indexOf()

// function checkFileExtension(fileName, ext) {
//   const fileExtIndex = fileName.indexOf(".");
//   const fileExt = fileName.slice(fileExtIndex);
//   if (fileExt === ext) {
//     return "File extension matches";
//   } else {
//     return "File extension does not match";
//   }
// }
// console.log(checkFileExtension("styles.css", ".css"));

// Інкремент.
// Що робить інкремент? По факту він або збільшує наше значення змінної на одиничку, або зменшує наше значення змінної на одиничку

// let a = 5;

// a++; // a = a + 1
// a++; // a = a + 1
// console.log(a); // a = 7

// Різниця в тому, що є префіксний і постфіксний інкремент і декремент.
// Різниця тут буде, як ви будете використовувати значення цього інремента(декремента), в якихось виразах або якийсь матемтичний вираз будете писати

// Постфіксний декремент

// let a = 5;
// console.log(a + a++); // 10
// console.log(a); // 6

// Ми отримали 10, хоча (а) у нас уже 6, чому?
// Тому що, спочатку ми пять додали до (поточного значення змінної (а)) пяти і отримали результат 10.
// А потім збільшили значення змінної (а) на одиничку і отримали 6
// Тобто, спочатку ми використали значення змінної (а) і відбулася ось ця дія 5 + а і ми отримали 10.
// А потім ми оновили значення нашої змінної і відбулася дія а + 1 і отримали 6.

// Префіксний декремент

// let a = 5;
// console.log(a + ++a); // 11
// console.log(a); // 6

// При префіксному декременті спочатку оновлюється значення змінної (а) на одиничку і ми отримаємо 6.
// А після цього вже відбувається математична дія 5 + 6 і ми отримаємо 11.
// Ось в чому фундаментальна різниця між префіксним і постфіксним інкрементом.
// У постфіксному спочатку відбувається дія зі змінною, потім буде оновлення цієї змінної.
// У префіксному спочатку відбувається оновлення змінної, а потім буде відбуватися дія зі змінною.

// У декрементів все ідентично
