/* ======================================================================================================================
Асинхронні функції
====================================================================================================================== */

/*Синтаксис async/await — це зручний спосіб 
написання асинхронного коду, який ззовні 
схожий на синхронний. Цей механізм був 
доданий до стандарту ECMAScript 2017 (ES8) 
і став дуже популярним серед розробників 
завдяки його зручності та зрозумілості. 
Будь-яка функція може бути асинхронною.


Для оголошення асинхронної функції перед 
ключовим словом function додається async.*/

// async function fetchData() {
//   // ...
// }

/*У функціональному виразі також перед 
ключовим словом function додається async.*/

// const fetchDataetch = async() => {
//   // ...
// }

/*Для оголошення асинхронного методу об'єкта 
async додається перед іменем методу.*/

// const user = {
//   async getUsername() {
//     // ...
//   },
// };

/*Для оголошення асинхронного методу класу 
також використовується async перед іменем методу.*/

// class User {
//   async getUsername() {
//     // ...
//   }
// }

// ----------------

/*Яке ключове слово використовується для 
оголошення асинхронної функції?

Ключове слово, яке використовується для 
оголошення асинхронної функції, це async.*/

/* ======================================================================================================================
Значення, що повертається
====================================================================================================================== */

/*В основі async/await лежать проміси, тому він 
не блокує основний потік виконання програми. 
По суті, це сучасний спосіб роботи з промісами 
всередині функції, і це є альтернативою 
конструкції then/catch.

Асинхронна функція завжди повертає проміс. Отже, 
будь-яке значення, що повертається з функції, 
стане значенням проміса.*/

// const foo = async () => {
//   return 5;
// };

// foo().then(value => {
//   console.log(value); // 5
// })

// -----------------

/*Якщо не вказувати значення для повернення, 
буде створений проміс зі значенням undefined.*/

// const foo = async () => {
//   // Не вказуємо значення для повернення
// };

// foo().then(value => {
//   console.log(value); // undefined
// });

// ------------

/*Що повертає асинхронна функція?

Асинхронна функція завжди повертає проміс.*/

/* ======================================================================================================================
Оператор await
====================================================================================================================== */

/*Всередині асинхронних функцій можна використовувати 
оператор await, розмістивши його праворуч від будь-якого 
виразу, який повертає проміс.*/

// const foo = async () => {
//   console.log("Before await");
//   const promiseValue = await new Promise(resolve => {
//     setTimeout(() => resolve(5), 2000)
//   });

//   console.log("After await", promiseValue);

// };

// foo(); // через 2 секунди виведеться в консоль  "After await" 5

/*Коли інтерпретатор зустрічає await, 
він призупиняє виконання функції і чекає, 
доки не завершиться виконання промісу, 
який знаходиться праворуч від await.


Якщо проміс успішно завершується (виконується), 
то виконання функції продовжується, і результат 
асинхронної операції стає доступним для використання.


У змінній promiseValue зберігається не сам проміс, 
а результат його виконання — у прикладі це число 5. 
Це тому, що інтерпретатор призупиняє функцію foo, 
коли зустрічає оператор await, і чекає, доки 
відповідний проміс завершить виконання, а потім, 
коли результат доступний, він продовжує виконання 
функції, записуючи результат у змінну.*/

// ---------------

/*Підсумуємо:

  1. Оператор await можна використовувати 
тільки всередині асинхронних функцій (async).
  2. await не може використовуватись без async, 
але async може використовуватися без await.
  3. Оператор await призупиняє виконання 
функції до завершення відповідного промісу 
(fulfilled або rejected).
  4. Якщо проміс завершується успішно 
(fulfilled), оператор await повертає його значення.
  5. Якщо проміс завершується з помилкою 
(rejected), оператор await генерує помилку.
  6. Асинхронна функція завжди повертає проміс, 
отже, будь-яке значення, що повертається, стає 
значенням цього промісу.
  7. Якщо не вказати значення для повернення, 
буде створений проміс зі значенням undefined.*/

// ----------------

/*Що робить оператор await у коді?

Оператор await чекає завершення асинхронної 
операції та повертає її результат.

------------------

Де можна використовувати оператор await?

В асинхронних функціях (функціях, 
оголошених ключовим словом async)
*/

/* ======================================================================================================================
HTTP-запити
====================================================================================================================== */

/*Використаємо синтаксис async/await при роботі 
з HTTP-запитами, щоб зробити код більш читабельним.

Давай перепишемо функцію fetchUsers, 
використовуючи цей синтаксис.*/

// import axios from "axios";

// const fetchUsers = () => {
//   axios.get("https://jsonplaceholder.typicode.com/users")
//     .then(response => {
//       console.log(response.data);
//       // (10) [{...}, {...}, {...}, {...}, {...}, ...]
//     });
// };

// fetchUsers();

/*Щоб зробити її асинхронною, спочатку 
додаємо ключове слово async.*/

// const fetchUsers = async () => {
//   // ...
// }

/*Потім ми використовуємо оператор await, 
щоб зачекати завершення axios.get та 
отримати об'єкт відповіді у змінну response.*/

// import axios from "axios";

// const fetchUsers = async () => {
//   const response = await axios.get(
//     "https://jsonplaceholder.typicode.com/users"
//   );
//   console.log(response.data);
//   // (10) [{...}, {...}, {...}, {...}, {...}, ...]
// };

// fetchUsers();

/*Якщо результат HTTP-запиту потрібно 
використовувати в зовнішньому коді, 
просто поверни його значення з асинхронної функції та оброби його в методі then.*/ 

// import axios from "axios";

// const fetchUsers = async () => {
//   const response = await axios.get(
//     "https://jsonplaceholder.typicode.com/users");
//   return response.data;
// }

// fetchUsers()
//   .then(users => console.log(users));

/* ======================================================================================================================
Конструкція try…catch
====================================================================================================================== */

/*Конструкція try...catch — це механізм обробки 
винятків. Ти можеш створити блок коду у try, де 
виникнення помилок відстежується, і задати 
блок catch, де можна обробити ці помилки.*/

// try {
//   // Блок коду, де можуть виникати помилки
// } catch (error) {
//   // Блок коду для обробки помилок, що виникли у блоці try
// }

/*Коли у блоці try виникає помилка (виключення), 
виконання коду у try зупиняється, і контроль 
передається до блоку catch. Параметр error 
представляє об'єкт помилки, в якому зазвичай 
міститься інформація про помилку, така як 
повідомлення про помилку.


Цей механізм дозволяє гнучко обробляти помилки 
і приймати відповідні рішення. Ти можеш продовжити 
виконання програми, обробивши помилку у блоці catch, 
або повідомити користувачеві про помилку.


Розглянемо приклад: ми намагаємося поділити число 
на нуль, що призводить до помилки. За допомогою 
try...catch можна перехопити цю помилку та 
вивести повідомлення про неї.*/

// console.log("Before try...catch");

// try {
//   const result = 10 / 0;
//   console.log(result); // Цей рядок не виконається через помилку
// } catch (error) {
//   // Обробимо помилку
//   console.error(error.message);
// }

// console.log("After try...catch");

// -----------------

/*Що робить конструкція try...catch?

Виконує код у блоці try, а якщо він 
викидає помилку, виконує код у блоці catch*/ 

/* ======================================================================================================================
Обробка помилок
====================================================================================================================== */

/*
Якщо результат асинхронної функції (проміс) 
не використовується в зовнішньому коді, помилки 
оброблюються у самому тілі функції за допомогою 
конструкції try...catch. Значення параметра 
error у блоці catch — це помилка, яку генерує 
await, якщо проміс був відхилений.*/ 

// import axios from "axios";

// const fetchUsers = async () => {
//   try {
//     const response = await axios.get(
//       "https://jsonplaceholder.typicode.com/users"
//     );
//     console.log(response.data);
//   } catch(error) {
//     console.log(error);
//   }
// }

// fetchUsers();

/*Якщо результат асинхронної функції (проміс) 
використовується в зовнішньому коді, тобто за 
межами інших асинхронних функцій, помилки 
оброблюються методом catch() колбеку. 
Значення параметра error у методі catch() — 
це помилка, яку генерує await, якщо проміс 
буде відхилений.*/

// import axios from "axios";

// const fetchUsers = async () => {
//   const response = await axios.get(
//     "https://jsonplaceholder.typicode.com/users"
//   );
//   return response.data;
// };

// fetchUsers()
//   .then(users => console.log(users))
//   .catch(error => console.log(error));

/*Якщо результат асинхронної функції використовується 
в іншій асинхронній функції, помилки оброблюються 
конструкцією try...catch. Значення параметра error 
у блоці catch представляє помилку, яку генерує await, 
якщо проміс буде відхилений.*/ 

// import axios from "axios";

// const fetchUsers = async () => {
//   const response = await axios.get(
//     "https://jsonplaceholder.typicode.com/users"
//   );
//   return response.data;
// };

// const doStuff = async () => {
//   try {
//     const users = await fetchUsers();
//     console.log(users);
//   } catch (error) {
//     console.log(error);
//   }
// };

// doStuff();