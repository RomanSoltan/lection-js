"use strict";
/* Можна не всі аргументи збирати в 
масив за допомогою rest оператора, а
зібрати лише певну кількість */

// function foo( a, b, ...args) {
//   console.log(a);
//   console.log(b);
  
//   console.log(args);
  
// }

// foo(1, 2, 3, 4,5)

/**
 * Функція зворотнього виклику (callback)
 * 
 * - Функція як значення
 * - Колбек-функції
 * - Інлайн-колбеки
 */

/* Під час виклику функції fnA потрібно
передати два аргумети: 
1. рядочок "Alice"
2. функцію fnB (виключно посилання, не викликаємо)

Якщо функція була передана як аргумент, то це
означає, що її можна прийняти в іншій функції, під 
час її створення, як параметр. Після цього можна 
викликати функцію callback, тобто fnB в тілі fnA.
Сallback в свою чергу хоче отримати в себе якийсь
рядочок, передаємо, як аргумент рядок message.

Як це працює?
1. Запускається функція fnA, передаючи їй, як 
аргумент рядок "Alice" і посилання на функцію fnB.
2. Йдемо в функцію fnA, де як аргуметом передані в 
message рядок "Alice" і в callback функція fnB.
3. Якщо функція fnB передана як аргумент, який ми 
назвали callback(назви параметрів довільні), 
то це означає, що її можна викликати у тілі 
функції fnA.
4. Далі ми запускаємо callback, замість якого 
піставиться функція fnB, і передамо їй як аргумент
message рядок "Alice".
5. Це означає, що ми йдемо у функцію fnB і починаємо
виконувати код у тілі цієї функції.
6. У тілі функції fnB виконуєься код, який передбачає 
виведення у консоль шаблонного рядка, де за допомогою
інтерполяції переданна зміна str, яка була передана, 
як параметр, при створенні функції fnB.
7. В результаті ми отримаємо рядок "Hello Alice"

Тобто callback функція, це звичайна функція, але 
вона передається в іншу функцію, як аргумент, 
під час її виклику.

У функцію fnA, під її час виклику, можна передати
інші функції, як аргумент, під час її виклику.

Функція, що була передана як аргумент в іншу
функцію, під час її виклику, називається 
Функція зворотнього виклику (callback)*/

// //            Alice      fnB
// function fnA(message, callback) {
//   // fnB("Alice")
//   callback(message);
// }

// function fnB(str) {
//   console.log(`Hello ${str}`);
  
// }

// fnA("Alice", fnB);

// ------------------------------------------------------

/**
 * Функція calc(a, b, callback)
 */

/* 
Якщо ми зберігаємо у змінну result  
результат виконання функції callback,
то це означає, що callback має щось
повертати.

Можна створювати callback функцію
одразу під час виклику функції, в яку
callback був переданий, як аргумент.
Для цього можна не писати назву функції
і залишити її анонімною, достатньо лише 
прописати ключове слово function, при 
створенні callback. І оскільки callback
передається, як аргумент при виклику, 
то він одразу прилетить в якості параметра
у функцію, яка створюється. 

callback буде приймати два параметри
x і y. І повертати результат виконання 
додавання цих параметрів.
*/

// function calc(a, b, callback) {
//   // console.log(callback); 
//   /* у callback функція, яка 
//   приймає x, y та повертає результат
//   додавання x, y
//   */

//   const result = callback(a, b);
//   // console.log(result); 
//   return result;
// } 

// console.log(calc(2, 3, function(x, y) {
//   return x + y;
// })); // 5

// console.log(calc(10, 8, function(x, y) {
//   return x - y;
// })); // 2


/**
 * Напишіть функцію each(array, callback), яка 
 * першим параметром очікує масив, а другим - 
 * функцію, яка застосовується до кожного елементу
 * масиву. Функція each повинна повернути новий 
 * масив, елементами якого будуть результати 
 * виклику callback.
 */

/* Якщо щось повертається в місце виклику функції,
то використовується оператор return.

1. for...of це цикл, який перебирає масив array.
2. В callback буде посилання на функцію, яка 
створена у виклику функції each і передана їй як
аргумент. Вона приймає якийсь аргумент і повертає
результат множення цього аргумента на 2 в місце 
свого виклику.
4. В циклі у callback буде зберігатися елемент масиву,
який буде передаватися у місце створення callback,
де з цим елементом буде відбуватися математична дія.
4. Після цього цей результат буде додано до нового
масиву 
5. Це буде відбуватися на кожній 
ітерації циклу.

Суть callback функцій у тому, що ми можемо в них
прописати певну логіку, яка виконуються при їх створенні,
і викликати callback у тілі функцій. 
Тобто не потрібно щоразу писати
новий код і створювати нові функції. 
Тобто callback створюють для перевикористання і 
владають у нього певну логіку. 

*/

// function each(array, callback) {
//   const newArr = [];

//   for(const num of array) {
//     const res = callback(num);
//     newArr.push(res);
//   }
//   return newArr;
// }

// console.log(each([64, 25, 17], function(value) {
//   return value * 2;
// }));

// console.log(each([64, 25, 17], function(value) {
//   return value - 10;
// }));

// ============================================== 2

/**
 * Стрілочні функції
 * 
 * - Оголошення
 * - Явне і неявне повернення
 * - Псевдомасив arguments (...args)
 * - Інлайн срілочні функції
 */

// 1 спосіб

// function add(a, b, c) {
//   return a + b + c;
// }

// console.log(add(1, 2, 3));

// 2 спосіб Стрілочні функції

/*
Синтаксис
const addArrow = (param) => { тіло функції }

За рахунок того, що є цей знак =>,
ці функції називають стрілочними.

Різниця між двома способами у тому, що якщо функція
створена як змінна, то ми не можемо звернутися до неї 
до моменту її ініціалізації.

Цей синтаксис функції є коротшим і 
зручнішим у написанні.
Ця функція записується у вигляді 
функціонального виразу, тобто через змінну.
У цій функції можна отримувати параметри, які
записуються у круглих дужках, якщо параметр
один, то дужки можна опустити, якщо немає 
параметрів, то круглі дужки обовязкові. 
Також можна повертати певний результат 
виконання коду з тіла функції.
Явне повернення - за допомогою return і якщо в тілі 
виконується декілька дій.
Неявне повернення - опускаємо фігурні дужки, і після 
стрілки одразу пишемо те, що потрібно повернути, якщо в 
тілі функції виконується лише одна дія, поаернення чогось
і немає складих обчислень.  

У стрілочних не існує такої сутності, як arguments.
Ця проблема вирішується за допомогою rest оператора, 
який може всі аргументи, які були передані у функцію
під час виклику зібрати у масив. 

*/

// // Явне повернення
// const add = (a, b, c) => {
//   return a + b + c;
// }

// // Неявне повернення
// const add1 = (a, b, c) => a + b + c;


// console.log(add(1, 2, 3));


// Якщо потрібно повернути обєкт

// 1 спосіб
// const foo = () => {
//   return {
//     b: 10,
//   }
// }

// 2 спосіб
// const foo = () => ({ b: 10,});

// console.log(foo());


// const calc = (a, b, callback) => {
//   const res = callback(a, b)
//   console.log(res);
  
// }

// calc(2, 3, (x, y) => {
//   return x + y
// });

// calc(5, 3, (x, y) => x - y);

/* 
Звичайні функції отримуюь контекст під
час їх виклику.
Стрілочні отримують контекст, там де вони 
створюються і беруть його з батьківської
області.
*/

// ============================================ 3

/**
 * Метод forEach(callback)
 * 
 * - Поелементно перебирає оригінальний масив
 * - Нічого не повертає
 * - Замінює класичний for, якщо не потрібно
 * переривати цикл.
 */

/*
Метод масиву forEach(callback)

Що він робить?
Цей метод поелементно перебирає масив, при
цьому нічого не повертає і його можна 
використовувати замість for, якщо не 
порібно переривати цикл, тобто припиняти
роботу нашого циклу.

Для того, що використати це й метод
потрібно наступне:
1. Звернутись до масиву.
2. Через крапку викликати метод forEach().
3. Метод в себе, як аргумент приймає
функцію, це означає callback-функцію.
4. callback буде у вигляді стрілки.
У перебираючих методах масивів 
стрілки дуже зручно використовувати.
Менше писати коду.
5. Метод forEach у функцію, яку він прийняв
як аргумент буде передавати наступні праметри
  1. Це параметр, який є елементом масиву, що
  викликав метод. Елемент має довільну назву.
  2. Це параметр, який показує індекс 
  цього елемента. Має довільну назву, але 
  називають i або index за замовчуванням.
  3. Це посилання на вихідний масив, з яким
  ми зараз працюємо.
  Якщо нам не потрібні деякі параметри, то ми
  можемо їх опустити і не використувати. 
  Зазвичай працюють лише з першим параметром, 
  в якому зберігаються елементи масиву.
  Головне дотримуватися послідовності.
6. Метод forEach перебирає масив і працює 
аналогічно циклу for, за винятком того, що 
його не можна перервати, тобто метод буде 
працювати поки не перебере увесь масив.
7. Так як метод forEach нічого не повертає
в ньому доцільно використувати неявне повернення
у стрілках.

*/

// const arr = [5, 10, 15, 20, 25];

// 1 спосіб
// arr.forEach(function(lalala) {
//   console.log(lalala);
  
// })

// 2 спосіб практичний
// arr.forEach((num, index, array) => {
//   console.log(num, index, array);
  
// });

// let total = 0;

// arr.forEach((num) => {
//   total += num;
// });

// те саме, що вгорі, тільки коротше
// arr.forEach(num => total += num);

// console.log(total);

// --------------------------------------------

/**
 * Виконайте рефакторинг коду за допомогою
 * методу forEach та стрілочної функції
 */

// function logItems(items) {
//   console.log(items);
//   for(let i = 0; i < items.length; i++) {
//     console.log(`${i + 1} - ${items[i]}`);
//   }
// }

// Рефакторинг
// const logItems = arr => {
//   arr.forEach((item, index) => {
//     console.log(`${index + 1} - ${item}`);
//   });
// }

// logItems(["Mango", "Poly", "Ajax"]);
// logItems(['🍎', '🍇', '🍑', '🍌', '🍋']);

// -------------------------------------------------

/**
 * Виконайте рефакторинг коду за допомогою
 * методу forEach та стрілочної функції
 */

// function printContactsInfo({ names, phones }) {
//   const namesArr = names.split(",");
//   const phonesArr = phones.split(",");
//   for(let i = 0; i < namesArr.length; i++) {
//     console.log(`${namesArr[i]}: ${phonesArr[i]}`);
    
//   }
// }

// Рефакторинг

// const printContactsInfo = (obj) => {
//   const namesArr = obj.names.split(",");
//   const phonesArr = obj.phones.split(",");

//   namesArr.forEach((item, index) => {
//     console.log(`${item}: ${phonesArr[index]}`);
    
//   });
  
// }

// printContactsInfo({
//   names: "Jacob,William,Solomon,Artemis",
//   phones: "89001234567,89001112233,890055566377,8900556300",
// });

// ----------------------------------------------

/**
 * Виконайте рефакторинг коду за допомогою
 * методу forEach та стрілочної функції
 */

// function calculateAverage(...args) {
//   let total = 0;
//   for (let i = 0; i < args.length; i++) {
//     total += args[i]
//   }
//   return total / args.length;
// }

// Рефакторинг

// const calculateAverage = (...args) => {
//   let total = 0;
//   args.forEach(num => total += num);
//   return total / args.length;
// }

// console.log(calculateAverage(1, 2, 3, 4)); // 2.5
// console.log(calculateAverage(14, 8, 2)); // 8
// console.log(calculateAverage(27, 43, 2, 8, 36)); // 23.5

// ========================================= 4

/**
 * Array.prototype.map()
 * - Поелементно перебрає оригінальий масив
 * - Не змінює оригінальний масив
 * - Повертає новий масив такої ж довжиниа
 */

/*
Що робить метод map()?
Метод map() це метод масиву.
Він поелементно перебирає оригінальний масив,
при цьому не змінючи його, і повертає новий 
масив такої ж довжини.   
*/

// const allCars = [
//     { make: "Honda", model: "CR-V", amount: 14, price: 24045 },
//     { make: "Honda", model: "Accord", amount: 2, price: 22455 },
//     { make: "Mazda", model: "Mazda 6", amount: 8, price: 24195 },
//     { make: "Mazda", model: "CX-9", amount: 7, price: 31520 },
//     { make: "Toyota", model: "4Runner", amount: 19, price: 34210 },
//     { make: "Toyota", model: "Sequoia", amount: 16, price: 45560 },
//     { make: "Toyota", model: "Tacoma", amount: 4, price: 24320 },
//     { make: "Ford", model: "F-150", amount: 11, price: 27110 },
//     { make: "Ford", model: "Fusion", amount: 13, price: 22120 },
//     { make: "Ford", model: "Explorer", amount: 6, price: 31660 },
// ];

/**
 * Нехай функція getModels повертає масив 
 * моделей (поле model) всіх автомобілів.
 */

// 1 спосіб Метод forEach
// const getModels = (cars) => {
//   const res = [];
//   cars.forEach(car => {
//     res.push(car.model);
//   });
//   return res;
// };

// console.log(getModels(allCars));

// 2 спосіб Метод map

/*
1. Оскільки метод map на відміну від forEach
повертає новий масив, це означає що не потрібно 
створювати додаткову зміну для зберігання масиву,
а далі в тілі пушити в неї.
2. Натомість можна створити змінну і одразу в неї 
присвоїти результат виконання методу map, який 
поверне новий масив такої ж довжини.
3. Викликаємо для масиву cars метод map()
4. Метод map() приймає в себе callback функцію,
як аргумент, яку можна записати як стрілочну.
5. callback в себе приймає наступні параметри
  1. Елемент масиву, який перебирається
  2. Індекс цього елемента
  3. Посилання на масив, який перебирається
Якщо деякі параметри не потрібні, то їх можна
опустити.
6. Що робить метод map()?
callback повинен повертати значення, яке ми 
отримаємо у тілі callback-функції. З цього 
значення буде формуватися новий масив, який 
буде такої ж довжини, як масив котрий 
перебирається. 
7. З тіла callback потрібно повернути
модель авто. У змінній car лежить елемент 
масиву, а саме обєкт. Для того щоб повернути
модель потрібно достукатися до властивості з 
ключем model.
8. Оскільки метод map хоче отримати на кожному 
кроці, те що повертає стрілочна функція, то 
можна використати неявне повернення.
9. Те що буде повертати callback у методі map,
те ми і отримаємо у нашому новому масиві.


*/

// const getModels = cars => {
//   const res = cars.map(car => car.model);
//   return res;
// }

// тотожний запис
// const getModels = cars => {
//   return cars.map(car => car.model);
  
// }

// Тотожний запис
// const getModels = cars => cars.map(car => car.model);

// console.log(getModels(allCars));

// ----------------------------------

/**
 * Нехай функція makeCarsWithDiscount 
 * повертає новий масив об'єктів із змінним
 * значенням властивості price залежно від 
 * переданої знижки.
 */

// const makeCarsWithDiscount = (cars, discount) => {
//   return cars.map(car => {
//     return {
//       ...car,
//       price: car.price * (1 - discount),
//     }
//   })
// }

// console.table(makeCarsWithDiscount(allCars, 0.2));
// console.table(makeCarsWithDiscount(allCars, 0.4));

// ------------------------------------

// const players = [
//     { id: "player-1", name: "Mango", timePlayed: 310, points: 54, online: false },
//     { id: "player-2", name: "Poly", timePlayed: 470, points: 92, online: true },
//     { id: "player-3", name: "Kiwi", timePlayed: 230, points: 48, online: true },
//     { id: "player-4", name: "Ajax", timePlayed: 150, points: 71, online: false },
//     { id: "player-5", name: "Chelsy", timePlayed: 80, points: 48, online: true },
// ];
  
/*
* Збільшуємо кількість годин гравця за id
*/

/* 
Метод map поверне масив такої ж довжини, як масив
який його викликав. І в новий масив буде сформований
із значень, які повертаються з колбек-функції, яка 
розташована всередині методу map.
*/

// const playerIdToUpdate = "player-3";

// const updatePlayers = players.map(player => {
//   if(playerIdToUpdate === player.id) {
//     return {
//       ...player,
//       timePlayed: player.timePlayed + 100,
//     }
//   }
//   return player;
// })

// console.table(updatePlayers);

/*
Висновки

1. Метод map в місці свого виклику повертає
новий масив
2. Цей масив буде такої самої довжини 
як і вихідний масив, тобто масив на якому у нас
обробляється метод map.
3. Сформований новий масив буде з елементів, які 
повертаються з callback-функції.
*/

// =================================== 5

/** 
 * Метод flatMap
*/

/* 
Метод flatMap викорисовується менш часто.
1. Цей метод приймає в себе callback-функцію, 
яку запишемо у формаі стрілочної.
2. Ця callback-функція буде приймати в 
себе три параметри:
  1. Елемент масиву
  2. Індекс цього елемента
  3. Посилання на масив, з яким працюємо
3.Якщо будь-який з параметрів не потрібен, то 
його можна опустити.
4. Метод flatMap також буде формувати новий
масив на основі значень, які поверуться з 
callback-функції.
5. Але на відміну від метода map розгортає масиви
лише першого рівня вкладеності, тобто витягне з 
масивів кожен елемент і покладе його в новий
результуючий масив.
6. Метод flatMap існує для того, щоб розгортати
масиви.
*/

// const tweets = [
//   { id: "000", likes: 5, tags: ["js", "nodejs"] },
//   { id: "001", likes: 2, tags: ["html", "css"] },
//   { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
//   { id: "003", likes: 8, tags: ["css", "react"] },
//   { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
// ];

// const tags = tweets.map(tweet => tweet.tags);

// const tags = tweets.flatMap(tweet => tweet.tags);

// console.log(tags);

// ---------------------------------------------------

/* 
Чиста функція 
1. не змінює зовнішні дані або параметри,
які передаються посилальним типом
2. При одих і тих самих вхідних 
параметрах функція буде повертати один 
і той самий результат
*/

// чиста функція
// function add(a, b) {
//   return a + b;
// }

// console.log(add(2, 5));
// console.log(add(2, 5));
// console.log(add(2, 5));


// не чиста функція
// const numbers = [1, 2, 3];

// function foo(arr) {
//   arr.forEach((item, index) => {
//     arr[index] = item * 2;
//   });
//   return arr;
// }

// console.log(foo(numbers)); // [2, 4, 6]
// // змінилися зовнішні дані
// console.log(foo(numbers)); // [4, 8, 12]
// console.log(numbers); // [4, 8, 12]
// // змінили початковий масив

// не чиста функція, бо random
// function foo(a, b) {
//   return a * b * Math.random();
// }

// console.log(foo(2, 4));
// console.log(foo(2, 4));
// console.log(foo(2, 4));