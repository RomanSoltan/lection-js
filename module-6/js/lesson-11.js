// ========================================== 1

/**
 * Контекст виконання функції
 * 
 * - Ключове слово this
 * - Глобальний контекст
 * - Контекст методу обєкта
 */




/** 
 * Глобальний контекст
*/

/*
Знайомство з контекстом. Що це таке?
Звідки береться?

Відповідь на питання про ключове 
слово this. 
Це більше треба запамятати.

Є звичайна функція. Ми спробуємо в ній 
отримати this.
Що таке this в нашій функції?
this посилається на обєкт, в контексті
якого викликана функція.
Спрощуємо. this буде посилатися на те, 
що стоїть зліва від нашої функції під час
її виклику. 
this в нашій функції буде 
ініціалізуватися, тобто потрапляти, під
час виклику функції. І от те, що стоїть
зліва від функції, під час її виклику, і 
буде контекстом this.
Зараз зліва від функції нічого не стоїть
і ми працюємо не в суворому режимі
("use strict"), то функція в себе 
контекстом отримає обєкт window, який 
має свої властивості і методи.
Тобто, якщо функція хоче в себе отримати
this і викликається глобально не в 
суворому режимі, то this буде послатися
на обєкт window. Якщо в суворому режимі
this буде посилатися на undefined, тобто 
контексту this небуде.
Це просто потрібно запамятати.
*/

// function foo() {
//   console.log("this", this); // window
// }

// foo();

// "use strict"
// function foo() {
//   console.log("this", this); // undefined
// }

// foo();

// -----------------------------------

/**
 * Контекст методу обєкта
 */

/*
У контексті методів обєктів this використовують
дуже часто і дуже багато.

Створимо обєкт user, де буде властивість з 
ключем userName і значенням Alice. І створимо 
метод showThis, тобто функцію, яка живе в обєкті, 
і в цій функції глянемо, а яким буде контекст 
у this. Для цього потрібно викликати цей метод
обєкту за допомогою user.showThis(), обовязково
мають бу круглі дужки - це для виклику.

Знову те саме правило:
this у методі showThis() буде обєкт, в контексті 
якого викликається ця функція. Або спрощено, те 
що стоїть ЗЛІВА від методу ПІД ЧАС ЙОГО ВИКЛИКУ
і буде this. Тобто контекст у функцію ми отримуємо
ПІД ЧАС ВИКЛИКУ цієї функції, не створення функції, 
а під час її виклику. І те, що стоїть зліва від 
методу під час його виклику, на те і буде посилатися
this у тілі функції. І оскільки зліва від нашого
методу showThis під час його виклику стоїть user, 
то а цей user і буде передаватися у this. 
Обєкт у контексті, якого функція викликана.
Або простіше. Що стоїть зліва через крапочку від 
методу, те й буде this

*/

// const user = {
//   userName: "Alice",
//   showThis() {
//     console.log("this", this);
//     // this {userName: 'Alice', showThis: ƒ}
//   }
// }

// user.showThis();

// ----------------------------------

/* 
У цьому прикладі this буде посилатися
на обєкт value. Тобто, те що стоїть 
зліва від функції під час її виклику, 
на те і буде посилатися this в її тілі.
*/

// const user = {
//   userName: "Alice",
//   value: {
//     price: 12,
//     showThis() {
//       console.log("this", this);
//       // this {price: 12, showThis: ƒ}
//     }
//   }
  
// }

// user.value.showThis();

// --------------------------------

/*
Але є невеличкий виняток, який стосується
стрілочних функцій
Такий синтаксис ми ще не розглядали.
Створимо стілочну функцію і подивимось на
контекст this. Це просто треба запамятати, 
хоча це рідко використовується.
this в стрілочній функції отримується не під
час виклику, а під час створення функції. 
І якщо ми викликаємо її в глобальній області видимості,
в будь-якому режимі(суворому чи ні), вона буде
посилатися на глобальний контекст window.
Тобто У СТРІЛОЧНИХ ФУНКЦІЯХ THIS ЗАВЖДИ БУДЕ
ПОСИЛАТИСЯ НА WINDOW.
*/

// const foo = () => {
//   console.log("this", this);
  
// }

// foo() // window

// -----------------------------

/* 
А тепер цікавий приклад, який покаже, чому
стрілочні функції не дуже використовують у 
обєкті, як методи.

Стрілочна функція, на відміну від звичайних,
контекст в себе отримує не під час виклику,
а під час створення. Тобто коли створив 
стілочну функцію, то вона одразу у себе
отримає контекст, який в ній 
залишиться назавжди. Контекст у методі 
showThis глобальний window, не обєкт user.
Дивно. А звідки ж window взявся? У стрілочних
функцій контекст береться з батьківської області
видимості під час створення.
*/

// const user = {
//   userName: "Alice",
//   // showThis() {
//   //   console.log("this", this);
//   // }

//   showThis: () => {
//     console.log("this", this);
//     // window
//   }
// }
// user.showThis();

// ---------------------------------------

/*
У даному прикладі стрілочна функція foo
створена у області видимості методу showThis,
отже стрілка під, час її створення,
забрала (скопіювала) собі контекст з цієї 
батьківської області видимості.
Це не дуже зручно, стрілочні функції, як методи
обєктів не використовуються.
*/

// const user = {
//   userName: "Alice",
//   showThis() {
//     console.log("this", this);
//     // {userName: 'Alice', showThis: ƒ}

//     const foo = () => {
//       console.log("foo", this);
//       // {userName: 'Alice', showThis: ƒ}
//     }

//     foo();
//   }
// }

// user.showThis();

/* 
Стрілочна функція отримує контекст з 
батьківської області видимості і отримує
його під час її створення, а не виклику.
*/

// ---------------------------------------

/** 
 * Контекст методу обєкта, але 
 * оголошений, як зовнішня функція.
*/

/* 
Створимо функцію showThis і поглянемо 
у ній на this. Далі створимо обєкт user
і в цьому обєкті створимо властивість з 
ключем userName і значенням "Kate". Далі
я хочу створити в обєкті user властивість.
Для цього напишу назву обєкта, поставлю
крапку і напишу назву нової 
властивості (showUserThis) і присвоюю в неї
посилання на функцію showThis. Посилання,
тобто я її не викликаю (без круглих дужок). 
Якщо така властивість є, то вона 
перезапишеться, якщо немає, то - створиться.
Консолимо user і дивимось, що в обєкті user
властивість userName, як була так і 
залишилась, і створилась нова властивість
з ключем showUserThis і значенням, в якому 
є посилання на функцію showThis. Тобто, якщо
ми викличемо user.showUserThis(), то 
запуститься функція showThis
Давайте запустимо. user.showUserThis().
Тримаємо в голові, що сюди ми присвоїли 
посилання на функцію showThis(). Це 
означає, що вона і запуститься. Запускається
функція showThis і вона хоче в консоль вивести
this, контекстом для якого буде обєкт user.
Те саме правило, що стоїть зліва від методу?
В контексті якого обєкту була запущена 
функція showUserThis()? В контексті обєкту,
що стоїть зліва від методу-функції, а саме 
в контексті обєкту user. Отже this буде 
посилатися на цей обєкт. 

*/

// function showThis() {
//   console.log("this", this);
//   // {userName: 'Kate', showUserThis: ƒ}
// }

// const user = {
//   userName: "Kate"
// }

// user.showUserThis = showThis;
// user.showUserThis() // showThis()
// console.log(user); // {userName: 'Kate', showUserThis: ƒ}

// /* 
// Якщо ми зробимо так як в прикладі нижче, 
// то в user.showUserThis одразу збережеться 
// результат виконання функції showThis()
// */

// function showThis() {
//   console.log("this", this);
//   // "this" window
// }

// const user = {
//   userName: "Kate"
// }

// user.showUserThis = showThis();
// console.log(user.showUserThis); // undefined
// user.showUserThis() // TypeError

// ----------------------------------------

/** 
 * Виклик без контексту, але 
 * оголошений як метод обєкта.
*/

/* 
Створимо обєкт user
В даному випадку у консолі буде
обєкт user і Petya
*/

// const user = {
//   userName: "Petya",
//   showThis() {
//     console.log("this", this);
//     console.log("username", this.userName);
//   }
// }

// user.showThis();
// // this {userName: 'Petya', showThis: ƒ}
// // username Petya

/*
Далі створимо зміну foo, в яку збережемо
посилання на функцію showThis. Після цього
у змінній foo буде зберігатися посилання на
функцію showThis. Тобто, коли ми запустимо 
foo, то в неї присвоїться результат виклику
функції showThis(), тобто те, що з неї
повернеться.  
Коли викличемо функцію foo в глобальній 
області, тобто під час виклику функції зліва 
нічого немає і код виконується не в суворому 
режимі, то this буде window, a this.userName
буде undefined.
В суворому режимі this буде undefined, а у
this.userName виникне помилка в консолі.

Тобто те, що стоїть зліва від функції під
час її виклику і буде контекстом, незалежно
від того чи викликається функція, як метод
обєкту(обєкт є контекстом), чи на функцію 
було збережено посилання у зміну і 
викликається ця змінна окремо, то контекст
втрачається (контекст буде window 
або undefined в суворому режимі).
 */

// const user = {
//   userName: "Petya",
//   showThis() {
//     console.log("this", this);
//     // this window
//     console.log("username", this.userName);
//     // username undefined
//   }
// }

// const foo = user.showThis;
// foo();

// console.log(foo);
/*
showThis() {
  console.log("this", this);
  // this window
  console.log("username", this.userName);
  // username undefined
}
*/ 

// ---------------------------------------------

/** 
 * Контекст у callback-функціях
*/
/*
Сallback-функція - це функція, яку ми
передаємо в іншу функцію, як аргумент.
*/

/* 
Створимо функцію logger, яка буде в себе,
як параметр приймати в себе callback.
При виклику функції logger потрібно їй 
передти як аргумент, посилання на функцію
showThis. У функцію logger в параметр
прилітає callback, посилання на функцію 
showThis. Тобто, ми можемо функцію showThis
використати в тілі нашого logger.
Якщо викличемо callback у тілі, то має
відпрацювати функція showThis.
В цьому випадку this посилається на 
глобальний обєкт window, a this.userName
undefined

Чому так?
Коли наш метод обєкту передається, як 
callback-функція, тобто аргументом в іншу
функцію під час її виклику, контекст 
втрачається. І знову наше правило.
Що стоїть під час виклику callback?
Нічого і режим не суворий, то this буде
window, a this.userName - undefined.
Тому що контекст у функцію showThis
порапляє під час виклику callback.
*/

// const user = {
//   userName: "Alice",
//   showThis() {
//     console.log("this", this); // window
//     console.log("username", this.userName);
//     // username undefined
//   }
// }

// function logger(callback) {
//   // console.log(callback);
//   callback();
// }

// logger(user.showThis);

// -----------------------------------------------

// ========================================= 2

// function foo() {
//   console.log("this", this);
// }

// foo(); // window

/* 
У змінну foo2 збережемо посилання на 
функцію showTitle (book.showTitle).
Викличемо foo2 і в результаті отримаємо
в консолі title undefined. Чому? 
Тому що при виклику функції foo2, вона
посилається на глобальний контекст
обєкта window. А функція showTitle
виводить у консоль властивість title
обєкта, який її викликає. Отже this
буде посилатися на window, виникне
такий вираз window.title, у window
властивості title немає, отже 
повернеться undefined. І у консолі буде 
title undefined.

Якщо це все у суворому режимі, то при 
виклику foo1 повернеться this undefined,
а foo2 поверне помилку, оскільки з 
undefined неможна отримати властивість
як з обєкту.
*/
// const book = {
//   title: "React",
//   showThis() {
//     console.log("this", this);
//   },
//   showTitle() {
//     console.log("title", this.title);
//   }
// }

// // book.showThis();
// // // this {title: 'React', showThis: ƒ, showTitle: ƒ}

// const foo1 = book.showThis; // посилання showThis
// foo1(); // this window 

// const foo2 = book.showTitle;
// foo2(); // title undefined

// -------------------------------------------------

/**
 * Напишіть метод calcTotalPrice(stoneName), 
 * який приймає назву каменю і
 * розраховує та повертає загальну вартість 
 * каменів з таким ім'ям, ціною та
 * кількістю з властивості stones.
 */

/* 
Нам кажуть створити метод calcTotalPrice(stoneName)
обєкту chopShop. Давайте одразу його вкличемо,
щоб було видно результат у консолі.
У console.log будемо звертатися до chopShop,
викликати метод calcTotalPrice() і передавати
сюди назву каменю Emerald. 
console.log(chopShop.calcTotalPrice("Emerald"))
1.Далі потрібно взяти масив каміння stones і 
перевірити чи є в цьому масиві елемент з іменем, 
яке ми отримуємо у метод calcTotalPrice, 
як параметр stoneName. 
2. Як отримати масив каміння? 
Для того, щоб отримати масив каміння
потрібно звернутися до обєкта в контексті, якого
викликається метод, тобто через ключове слово this, 
і звернутися до його властвості stones. 
Відповідь: this.stones
3. Далі потрібно знайти елемент в масиві stones.
Для цього підійде метод масиву find.
4. Find приймає в себе callback функцію.
5. Що вона отримує? Вона отримує елемент масиву,
тобто item.
6. Метод find поверне елемент, який задовільнить
умову у тілі callback, тобто умова поверне true
7. Потрібно порівняти назву каменю з масиву stones
із назвою каменю, яку ми отримаємо під час виклику 
методу calcTotalPrice.
7. Для того, щоб отримати назву каменю з масиву
потрібно прописати item.name, stoneName це назва,
яку ми отримуємо під час виклику.
8. В результаті перевірки ми отримаємо обєкт з 
масиву, який пройшов перевірку
({name: 'Emerald', price: 1300, quantity: 4}).
9. Що потрібно зробити далі?
Далі потрібо зробити перевірку, у разі якщо 
камінь не буде знайдено в масиві.
10. Зробити це можна з допомогою конструкції if,
де в умові запишемо !stone, щоб undefined в 
булевому вираженні перетворити на true, і якщо 
умова спрацює, то поверни рядок 
`${stoneName} not found`.
11. В іншому випадку повернемо результат
вартості каміння. Для цього потрібно помножити
з обєкта stone, який отримано з методу find
властивість кількості каменю на властивість ціни
stone.quantity * stone.price.
*/


// const chopShop = {
//   stones: [
//     { name: "Emerald", price: 1300, quantity: 4 },
//     { name: "Diamond", price: 2700, quantity: 3 },
//     { name: "Sapphire", price: 1400, quantity: 7 },
//     { name: "Ruby", price: 800, quantity: 2 },
//   ],
//   calcTotalPrice(stoneName) {
//     const stone = 
//       this.stones.find((item) => item.name === stoneName);
//     console.log(stone);
      
//     if(!stone) {
//       return `${stoneName} not found`;
//     }

//     return stone.quantity * stone.price;
//   }
// };

// console.log(chopShop.calcTotalPrice("Emerald"));

// ---------------------------------------------------

// ==================================================== 3

/**
 * Контекст виконання функції
 * 
 * - Метод call
 * - Метод apply
 * - Метод bind
 */

/*
Знайомство з методами функцій.
Навіщо вони потрібні?
*/

/*
Якщо ми хочемо, щоб функція showThis
посилалася на саме на якийсь з цих 
обєктів, то потрібно в кожному з цих
обєктів створити властивість, присвоїти
в неї посилання на функцію і коли ми
будемо викликати цю властивість в 
контексті обєкта this буде посилатися
на цей обєкт.

Але якщо я не хочу в обєкті створювати
додаткову властивість, вона там не 
потрібна, але хочу, щоб функція showThis
посилалась на певний обєкт. В цьому 
допоможуть методи call, apply, bind.
*/

// function showThis() {
//   console.log("this", this);
  
// }

// const objA = {
//   a: 5,
//   b: 10,
// }

// const objB = {
//   x: 100,
//   y: 150,
// }

// --------------------------------

// Метод call

/* 
Якщо викличемо функцію showThis
без контексту, тобто в глобальній області,
то this буде посилатися на обєкт window.
Якщо потрібно, щоб ця функція посилалась 
на конкретний обєкт, то при виклику цієї
функції, потрібно через крапку викликати 
метод call().

Цей метод першим аргументом приймає те, що
буде this у функції, тобто на який обєкт
this буде посилатися в тілі функції.
showThis.call(objA)

Метод call одразу викликав функцію showThis
і привязав до неї контекст обєкту objA, 
тобто this буде посилатися на обєкт objA.

Перший аргумент методу call привязується 
контекстом в функцію, яка через метод 
call викликається.
*/

// function showThis() {
//   console.log("this", this);
// }

// const objA = {
//   a: 5,
//   b: 10,
// }

// const objB = {
//   x: 100,
//   y: 150,
// }

// showThis.call(objA);

/*
1. Якщо в функцію showThis хочемо
отримати параметри, для цього треба
після першого аргументу в методі call
просто переліком передати ці дані.
2. Отже першим аргументом в методі call
буде обєкт, на який посилається this
у функції, все що наступне, це те, що
буде передано в функцію і отримається,
як параметр.
3. Ось таким чином можна передавати дані в
функцію, якщо потрібно привязати 
контекст і щось туди передати.

Висновок.
Метод call привязує контекст до 
функції, яка його викликала.
Контекстом буде перший аргумент переданий
в метод, і функція одразу викликається
*/

// function showThis(a, b, arr) {
//   console.log(a, b, arr);
  
//   console.log("this", this);
//   //  this {a: 5, b: 10}  
// }

// const objA = {
//   a: 5,
//   b: 10,
// }

// const objB = {
//   x: 100,
//   y: 150,
// }

// showThis.call(objA, 5, "lalala", [1, 2, 3]);

// --------------------------------------------

// Метод apply

/*
1. Звернемося до функції showThis і
і викличемо метод apply()
2. Метод apply так само існує для 
того, щоб передавати контекст до 
функції.
3. Першим аргументом, який передається 
в метод apply і буде контекстом функції,
яка викликала цей метод.
4. Яка різниця між call і apply?
Різниця полягає в тому, як передаються 
аргументи у функцію showThis при її
виклику.
5. У випадку, коли передаються аргументи 
у метод apply, вони повинні передаватися у 
вигляді масива, незалежно від того, як
функція їх хоче отримати.

Висновок.
Метод call i apply це методи функцій для 
привязуваня контексту.
Тобто викликати ці методи можуть 
тільки функції.
Контекст можа привязати лише в функцію.
*/ 

// function showThis(a, b, arr) {
//   console.log(a, b, arr);
//   // 5, "lalala", [1, 2, 3]
  
//   console.log("this", this);
//   // this {x: 100, y: 150}
// }

// const objA = {
//   a: 5,
//   b: 10,
// }

// const objB = {
//   x: 100,
//   y: 150,
// }

// showThis.apply(objB, [5, "lalala", [1, 2, 3]]);

// ------------------------------------------------

// Практика з вкористанням методів 
// функції apply i call.

/*
1. Створимо функцію changeColor(),
яка буде приймат в себе параметр
color.
2. Ця функція буде викликатися з
привязаним контекстом. Виведемо
цей контекст у консоль.
3. Функція буде змінювати колір.
Отже потрібно звернутися до обєкту, 
який буде привязаний до функції, 
а саме до його властивості color 
(this.color) і перепризначати йому
це значення параметром, який буде
приходити в color.
4. Є два обєкти, які мають певний
колір і функція, яка може цей колір
змінити
5. Як це можна зробити?
6. Потрібно до функції changeColor
привязати контекст.
7. Це можна зробити за допомогою
методів call і apply
8. Як це відбувається?
Запуститься функція changeColor до
неї привяжеться контекстом обєкт
sweater або hat. Потім функція 
змінює поточний колір на той, який 
був переданий при виклику методу 
для функції.

Висновок. 
Можна створити одну функцію, яка 
може змвнювати довільну кількісь
обєктів. Ми просто привязуємо до
цієї функції контекст обєкту і 
передаємо певний аргумент, якщо 
виникає така необхідність. 
*/

// function changeColor(color) {
//   console.log("this", this);

//   this.color = color
// }

// const hat = {
//   color: "black"
// }

// const sweater = {
//   color: "green"
// }

// changeColor.call(hat, "red");
// console.log("hat", hat);

// changeColor.apply(sweater, ["white"]);
// console.log(sweater);

// -----------------------------------------

// Метод bind

/* 
1. Метод call і apply одразу викликають функцію,
тобто функція одразу виконується. Привязали
контекст, викликали функцію і отримали результат.
2. Метод bind існує для привязування контексту
для функції, але не викликає її. bind повертє
копію функції з привязаним вже до неї контекстом
3. Створимо змінну changeHatColor, в якій буде
зберігатися результат виклику функції
changeColor, в якій звертаємося до методу bind.
4. Метод bind першим аргументом приймає значення, 
яке привяже контекстом обєкт у функції.
5. Оскільки bind не запускає одразу функцію, то 
цей метод привяже до функції контексом обєкт
hat і збереже цю функцію з привязаним контекстом
у змінну changeHatColor.
6. Тепер цю змінну можна викликати і передати їй
параметр для зміни кольору. changeHatColor("red");
7. Функція відпрацювала.

Висновок.
На відміну від apply i call, метод bind привязує
контекст до функції, але не викликає її, і повертає
посилання на цю функцію вже з привязаним контекстом. 
Це дає змогу це посилання зберегти у змінну і потім
викликати, коли потрібно.
*/

// function changeColor(color) {
//   console.log("this", this);

//   this.color = color
// }

// const hat = {
//   color: "black"
// }

// const sweater = {
//   color: "green"
// }

// const changeHatColor = changeColor.bind(hat);
// changeHatColor("red");
// console.log(hat);

// ---------------------------------------

/*
1. Створимо змінну changeSweaterColor, в яку 
збережемо результат виклику функції changeColor,
яка звертається до методу bind, де аргументами 
передамо обєкт, який буде контекстом привязаний
до функції.
2. Але тепер можна передавати аргументи, які 
потребує наша функція changeColor, не під час 
виклику, а коли викликаємо метод, як другим
аргуметом, тобто під чс привязки контексту.
*/ 

// function changeColor(color) {
//   console.log("this", this);

//   this.color = color
// }

// const hat = {
//   color: "black"
// }

// const sweater = {
//   color: "green"
// }

// const changeSweaterColor = changeColor.bind(sweater, "yellow");
// changeSweaterColor();
// console.log(sweater);

// ---------------------------------------------

// Розгляд прикладу

/*
1. Створимо обєкт, в якому буде value,
яке буде мати значення 0.
2. Створимо метод increment, який буде 
приймати значення і дивитися на контекст
this, буде звертатися до this.value і 
збільшувати його на параметр, який 
приходить в метод обєкту.
3. Своримо метод decrement, який буде
виводитись у консоль, приймати параметр,
звертатися до обєкта, який викликав цей
метод, до його властивості value і 
віднімати від нього параметр.
4. Створимо функцію updateCounter, одразу
її викличемо і передамо в неї значення.
5. Одразу її викличемо. Першим аргументом 
буде число 10, другим - callback 
функцію counter.increment
6. Передамо ці значення як параметри у 
функцію updateCounter.
7. Чим буде callback в функції updateCounter?
callback буде посиланням на функцію increment
8. Викликаємо callback у тілі updateCounter 
і передаємо value як аргумент.
9. В результаті у функцію increment 
отримали контекстом глобальний обєкт window.
10. І в обєкті counter value залишився 
незмінним, тому що counter не був привязаний 
контекстом до callback.
11. Коли передаємо метод обєкту як callback
функцію вона втрачає свій контекст.
12. Як виправити цю сиуацію?
Для цього у нас є метод bind. Він може 
привязувти контекст до функції і не викликти
її, а повертати посилання на цю функцію з 
привязаним контекстом.
13. Потрібно під час виклику функції 
updateCounter, коли ми передаємо callback,
як аргумент, привязати до нього контекстом,
за допомогою методу bind, обєкт counter.
14. І все працює. В функцію increment 
як контекст потрапляє обєкт counter
15. Метод call  не підійде, тому що він 
одразу викличе функцію, а потрібно 
передати посилання на функцію.
16. Аналогічно з декрементом.
*/

// const counter = {
//   value: 0,
//   increment(num) {
//     console.log("incremrnt", this);
//     this.value += num;
//   },
//   decrement(num) {
//     console.log("decrement", this);
//     this.value -= num;
//   }
// }

// function updateCounter(value, callback) {
//   callback(value);
  
// }

// updateCounter(10, counter.increment.bind(counter));
// updateCounter(1, counter.decrement.bind(counter));

// console.log(counter);

// --------------------------------------------------

/**
 * Прототип обєкта
 * 
 * - Object.create()
 * - Власні і невласні властивості
 * - Перебір власних властивостей з
 * hasOwnProperty()
 * - Ланцюжки прототипів 
 */

/*
Обєкт можна створити за допомогою
літерала обєкту. Але існує ще один
спосіб створення обєкту.
*/ 

/*
1. З допомогою Object.create() 
створюємо обєкт dog.
2. Animal тепер слугує прототипом 
для обєкту dog. 
3. Що таке прототип?
Прототип це додаткова властивість,
з якої ми можемо отримувати певні
властивості або певні методи.
Скажімо так додаткове резервне
сховище влстивостей і методів.
4. Що мені це дає?
За допомогою прототипів можна отримати
доступ до властивостей, яких немає у 
обєкті, але вони є у прототипі.
5. Чому так?
Властивість name є власною властивістю
dog. Коли до неї звертаєшся, то отримуєш
її значення.
6. Але якщо звертаємося до властивості,
якої немає в обєкті. 
Що відбувається тоді?
7. Тоді наш інтерпретатор іде шукати
цю властивість або метод у прототипах.
Занурююється вниз і бачить, що ця 
властивість є у прототипах і він її
повертає.
8. Якщо властивість не знайдена по 
ланцюжку прототипів, то 
повернеться undefined.
9. Властивість, яку ми бачимо і маємо у 
нашому обєкті називається власною.
Властивість, яку ми отримали з прототипа
називається невласною.
10. З методами та сама історія.
Методи дуже часто успадковуються, як
прототипи.
*/ 

// const animal = {
//   legs: 4
// }

// const dog = Object.create(animal);
// dog.name = "Shark"
// console.log(dog.legs);

// ------------------------------------

// Метод hasOwnProperty()

/* 
1. Інколи потрібно зрозуміти властивість,
яку ми отримаємо є власною чи невласною.
2. Як це зрозуміти?
3. Звернемося до обєкта dog і викликаємо
метод hasOwnProperty(), в який передаємо 
назву ключа власивості, яку потрібно 
перевірити чи власна вона, чи ні.
4. Результатом виконання методу буде
булеве значення true, якщо властивість 
власна, і false - невласна.
*/

// const animal = {
//   legs: 4
// }

// const dog = Object.create(animal);
// dog.name = "Shark"

// console.log(dog.hasOwnProperty("legs")); // false
// console.log(dog.hasOwnProperty("name")); // true

// -------------------------------------------

/*
Коли це може бути корисно?

1. В циклі for...in, який перебирає
ключі в обєкті.
2. Проблема в тому, що цикл перебирає
власні і невласні влстивості.
3. Щоб це виправити і потрібен 
метод hasOwnProperty(), з допомогою
якого можна здійснити перевірку для 
визначення власних і невласних 
властивостей.
*/ 

// const animal = {
//   legs: 4
// }

// const dog = Object.create(animal);
// dog.name = "Shark"

// for(const key in dog) {
//   if(dog.hasOwnProperty(key)) {
//     console.log(key); // name
//   }
// }

/*
Але приорітетніше буде просто
отримувати ключі з обєкта, з 
допомогою синтаксису Object.keys(),
який поверне масив лише власних ключів.
*/ 
// const keys = Object.keys(dog);
// console.log(keys);

// -----------------------------------------

// Ланцюжки прототипів

/*
Послідовність отрмання данних з 
прототипу.
1. Доступ до властивостей можна отримувати
за ланцюжком прототипів.
2. Якщо не знайшов властвості у обєкті, то 
далі шукає в прототипі, знайшов в прототипі 
повернув, хоч вона і не власна, і так доки 
не дійде до глобалього класу Object. Якщо 
і там нема, то поверне undefined.  
3. Ось за таким ланцюжком відбувається пошук
влстивостей і методів за прототипом.

*/ 

// const objC = { c: "objC"};

// const objB = Object.create(objC);
// objB.b = "objB";

// const objA = Object.create(objB);
// objA.a = "objA";

// // console.log(objA.a); // objA
// // console.log(objA.hasOwnProperty("a")); // true

// // console.log(objA.b); // objB
// // console.log(objA.hasOwnProperty("b")); // false

// console.log(objA.c); // objC
// console.log(objA.hasOwnProperty("c")); // false

// ------------------------------------------------


/**
 * Наше завдання написати програмне забезпечення
 * для автомобіля, а саме натискання кнопки 
 * набору та зниження швидкості в системі круїз 
 * контролю. Створити об'єкт cruiseControl 
 * з методами accelerate та decrease, 
 * властивостями speed та brand.
 */ 

// const cruiseControl = {
//   speed: 0,
//   brand: "Audi",
//   accelerate() {
//     this.speed += 10;
//     console.log(`Автомобіль ${this.brand} прискорюєтся, швидкість
//       ${this.speed}`);
    
//   },
//   decrease() {
//     if(this.speed <= 0) {
//       console.log("Гальмувати не потрібно, авто зупинилось");
//       return;
//     }
//     this.speed -= 10;
//     console.log(`Автомобіль ${this.brand} гальмує, швидкість
//       ${this.speed}`);
//   }
// }

// cruiseControl.accelerate();
// cruiseControl.accelerate();
// cruiseControl.decrease();
// cruiseControl.decrease();
// cruiseControl.decrease();
// console.log(cruiseControl);

// -----------------------------------------------------

/**
 * Потрібно створити функціонал для контролю
 * швидкості прокатних авто. Створіть функцію
 * яка буде приймати 1 параметр (максимально 
 * дозволену швидкість) та виводити повідомлення,
 * чи ми рухаємось з безпечною швидкістю чи 
 * перевищуємо, функція має опрацьовувати об'єкт 
 * автомобіля як this
 */


// const SPEED = 60;

// const bmw = {
//   brand: "bmw",
//   speed: 70,
// }

// const audi = {
//   brand: "audi",
//   speed: 30
// }

// function speedSensor(maxSpeed) {
//   // if(this.speed <= maxSpeed) {
//   //   return `Автомобіль ${this.brand} рухається 
//   //   з безпечною швидкістю`;
//   // }

//   // return `${this.brand} перевищує швидкість`;

//   return this.speed <= SPEED 
//     ? `Автомобіль ${this.brand} рухається`
//     : `${this.brand} перевищує швидкість`;
// }

// console.log(speedSensor.call(bmw, SPEED));
// console.log(speedSensor.call(audi, SPEED));

// -------------------------------------------

// Алгоритм визначення this

// Ключове слово this — це одна з 
// найзаплутаніших концепцій для новачка.

// Новачки часто підставляють this методом 
// наукового тику доти, доки скрипт не спрацює.

// Але все стає значно простішим, коли є 
// простий алгоритм визначення значення this.

// Крок 1

// Це стрілочна функція?

// Якщо відповідь Так, значення this те саме, 
// що у this у зовнішній області видимості
// Якщо відповідь Ні, переходь на Крок 2

// Крок 2

// Чи використовуються методи call, apply або bind?

// Якщо відповідь Так, значення this — це той 
// самий об’єкт, що передали при їх виклику
// Якщо відповідь Ні, переходь на Крок 3

// Крок 3

// Функція викликається як метод об’єкта object.method?

// Якщо відповідь Так, значення this — це об’єкт 
// ліворуч від крапки
// Якщо відповідь Ні, переходь на Крок 4

// Крок 4

// Скрипт виконується в суворому режимі?

// Якщо відповідь Так, значення this — undefined
// Якщо відповідь Ні, значення this — window