// ========================================== 1

/**
 * Класи
 * - Оголошення класу
 * - Конструктор класу
 * - Методи класу
 * - Прототип екземпляру
 * - Приватні властвості
 * - Геттери і сеттери
 * - Статичні властивості
 */

/* 
Класи. Що це таке? Навіщо вони потрібні?
*/  

/* 
Бувають ситуації, коли потрібно зробити
багато однотипних обєктів. 
Тобто обєктів:
	- в яких будуть одакові властивості, 
	але з різними данними в них 
	- які можуть мати доступ до одних 
	і тих самих методів 

Якраз для виконання цєї потреби у 
нас існують класи.

Яким чином можна створити клас?

1. Для цього потрібно написати ключове 
слово class і після цього власне
назву класа.
2. Назва класа починається з 
великої літери.
3. Після назви ставимо фігурні дужки.
4. Клас створено.
*/  
// class Car {

// }

// -------------------------------------------------

/*
Як можна створити екземпляр класу,
тобто обєкт на основі класу?

Клас існує для створення обєктів, отже 
з його допомогою можна створювати обєкти

1. Створимо зміну bmw, в яку присвоїмо
наступну комбінацію.
2. Напишемо ключове слово new, далі
через пробіл пишемо Car і ставимо круглі
дужки ().
3. Виведемо у консоль зміну bmw, де у нас
створився обєкт, який успадковується від
класу Car, тобто створений за його допомогою.
4. На даний момент обєкт порожній.
Як його наповнити контентом?
*/  
// class Car {

// }

// const bmw = new Car();

// console.log(bmw);

// -----------------------------------------------

/*
Як можна створити наповнення обєкту контентом?
Тобто створии властивості або методи і 
присвоїти їм певні значення.

1. Для того, щоб у клас передати дані, їх 
потрібно передавати під час виклику класу,
тобто під час створення нового екземпляру.
2. Передавати їх можна як завгодно, можна
просто переліком, можна передавати, як 
обєкт
3. Обєкт використовується частіше.
4. Передамо обєкт, в якому створимо
властивості brand i model. 
5. Але нічого в обєкті не змінилося.
Чому? Тому що дані в клас передані, але
їх ще потрібно отримати і використати.
*/  
// class Car {

// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7"
// });

// console.log(bmw);

// -----------------------------------------------

// Конструктор

/*
І ту ми підійшли до першого важливого 
моменту. В класах є такий метод,
який називається конструктор.

1. Коструктор оголошується так само, як
і методи в обєктах, за винятком того, що
у класах після них не ставимо коми.
2. Конструктор існує для того, щоб 
приймати передані дані, які ми передаємо
в клас під час створення нового екземпляру.
3. Яким чином можна прийняти передані
дані у конструкторі?
4. Потрібно зрозуміти одну істину.
Конструктор буде автоматично викликатися
під час створення екземпляру класу.
5. І контекст в методі конструктор буде
завжди посилатися на новостворений обєкт.
6. Тобто ключове слово this, у цьому випадку
буде посилатися на новостворений обєкт
екземпляр класу. 
7. Тобто, ящо буде створено декілька 
екземплярів, то в кожному окремому випадку,
буде автоматично запускатися конструктор, 
який буде посилатися на новостворений обєкт,
який створюється під час виклику нашої 
конструкції new Car.
*/  

// class Car {

// 	constructor(obj = {}) {
// 		this;
		
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7"
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5"
// });

// console.log(bmw);

// ------------------------------------------

/*
1. У конструкторі, як параметр, були
приняті певні дані новостворених 
екземплярів.
2. Як їх використати?
3. Можна в класі сказати:
"Створюй властивості з таким ключем і
певним значенням". Ці властивості будуть 
створюватися у кожному обєкті на який 
посилається конструктор. 
4. Тобто this посилається на конкретний
обєкт і в кожному обєкті можна створювати
властивості, якщо їх прописати у 
конструкторі (this.brand) 
5. Цим новосвореним властивостям, які 
створені з допомогою this, потрібно присвоїти
значення, яке потрапляє у конструктор, 
як параметр. У параметрі у нас зберігається
obj, щоб достукатися до власивості обєкта,
використовуємо синтаксис крапку (obj.brand).
6. В результаті створився обєкт bmw, в 
якому є властивість brand і model, і 
створився ще один обєкт bmw1, в якому 
так само є властивість brand і model.

Висновок.
За рахунок того, що конструктор посилається
безпосередньо на новостворений обєкт, 
this якраз буде цим обєктом, і ми можемо з 
допомогою this, за рахунок того, що ключі
мають однакову назву, створювати властивості 
у новоствореному обєкті.
Назви ключів задаються в конструкторі, а 
значення передаються ті, які були передані 
під час створення екзкмпляра.
*/  

// class Car {

// 	constructor(obj = {}) {
// 		this.brand = obj.brand;
// 		this.model = obj.model;
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7"
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5"
// });

// console.log("bmw", bmw);
// console.log("bmw1", bmw1);

// -----------------------------------------------

/* 
Створення методів в класі

1. Методи в класах створюються за подібним
ситаксисом, що і в обєктах
2. В методі this буде посилатися на обєкт, 
який викликає цей метод, що дає змогу 
працювати з кожним обєктом. Тобто не потрібно
кожному окремому обєкту писати окремо метод.
Ми створюємо в класі загальний метод для всіх
і він просто буде перевикористовуватися. 
3. Оскільки метод у класі не буде мати 
унікальних властивостей і метод буде 
універсальним, тобто він завжди буде 
посилатися на існуючий обєкт, який їх викликає,
і робити певні маніпуляції саме з ним. 
Тому необхідністі копіювати в кожен обєкт
методи немає.
4. А звідки вони беруться? У нашому випадку
методи беруться з прототипу, а точніше з класу Car.
5. Клас Car є прототипом, на основі якого 
створені обєкти. І коли будемо викликати метод,
контекстом якого будуть ці обєкти, ми у обєкта не 
знаходимо такого методу і йдемо шукати по 
ланцюжку прототипів. І знаходимо у класі Car, 
де він викликається.

Висновок. 
Властвості знаходяться в обєкті.
Методи знаходяться у прототипі.
*/  

// class Car {

// 	constructor(obj = {}) {
// 		this.brand = obj.brand;
// 		this.model = obj.model;
// 	}

// 	getModel(){
// 		return this.model
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7"
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5"
// });

// console.log("bmw", bmw.getModel()); // bmw X7
// console.log("bmw1", bmw1.getModel()); // bmw1 X5

// -----------------------------------------

// Приватна властивість

/*
1. Потрібно створити ще одну властивість у нашому
обєкті, яка буде називатися price і буде мати в 
собі певне значення.
2. Пропишемо у конструкторі, щоб створювалися наша
властивість.
3. Але є одна нвеличка проблема, яка на даному 
етапі може бут не дуже очевидною.
4. Створимо метод, який називається updatePrice,
що збільшує вартість на 1000.
5. Якщо викличемо цей метод в контексті обєкта
bmw, то price становитиме 71000.
6. Але є проблема, яка полягає в тому, що
властивості у обєкті є публічними, тобто 
загальнодоступними. І з ними можна взаємодіяти, 
як зі звичайними властивостями. 
7. Тому що, не завжди окей мати можливість напряму
змінювати властивість, тому що інший розробник буде
мати доступ і може випадково змінити дані в обєкті.
8. Для того, щоб запобігти цій проблемі потрібно
зробити властивість приватною.
9. Переваги приватної властивості у тому, що
нею можна користуватися тільки всередині класу, 
і не буде можливості комусь напряму її з обєкта
або отримувати, або змінювати.
10. Для того, щоб властивість зробити приватною,
для початку перед конструктором потрібно 
властивість оголосити, перед нею написавши #.
11. У конструкторі потрібно прописати this.#price,
тобто створиться в обєкті властивість з назвою 
#price і в неї присвояться дані, які бул отримані
під час створення екземпляру обєкта.
12. Тепер до властивості #price не можна звернутися 
напряму з екземпляру класу або з обєкта(при спробі
звернутися буде отримано undefined).
13. При спробі перезаписати створиься просто інша
властивість, не та сама.
14. Тобто тепер до вартості автомобіля немає
доступу ззовні
*/  

// class Car {
// 	#price;

// 	constructor(obj = {}) {
// 		this.brand = obj.brand;
// 		this.model = obj.model;
// 		this.#price = obj.price;
// 	}

// 	getModel(){
// 		return this.model
// 	}

// 	updatePrice() {
// 		this.#price += 1000;
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7",
// 	price: 70000
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5"
// });

// bmw.updatePrice();
// console.log("bmw", bmw);

// ------------------------------------------

// Як отримувати або змінювати 
// приватні властивості?

/*
1. Змінювати можна за тим самим принципом,
що й публічні. Викликаємо метод, тільки перед
назвою властивості потрібно поставити #.
2. Для того, щоб отримати аналогічно.
Можна створити наприклад метод getPrice(),
в якому повертати this.#price.
3. Таким чином можна взаємодіяти з 
приватними властивостями.

Висновок.
Приватні властивості потрібно обовязково
оголошувати перед конструктором.
*/ 

// class Car {
// 	#price;

// 	constructor(obj = {}) {
// 		this.brand = obj.brand;
// 		this.model = obj.model;
// 		this.#price = obj.price;
// 	}

// 	getModel(){
// 		return this.model
// 	}

// 	updatePrice() {
// 		this.#price += 1000;
// 	}

// 	getPrice() {
// 		return this.#price;
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7",
// 	price: 70000
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5"
// });

// bmw.updatePrice();
// console.log("bmw", bmw.getPrice()); // bmw 71000

// ---------------------------------------

// Геттери і сеттери

/* 
1. Чи можна взаємодіяти з приватними 
властивостями іншим способом?
2. Можна. Якщо у наших властивостях 
зберігаються примітивні типи даних, то 
для доступу і зміни властвостей можна
обійтися без методів. Методи для 
складних структур.
3. Для примітивів існують 
геттер і сеттери.
4. Що це? 
Це по факту теж методи, для взаємодії
з приватними властивостями, але з 
невеликою відмінністю.

5. Для створення геттера потрібно
прописати ключове слово get.
6. Якщо геттер буде взаємодіяти з 
приватною властивісю, то гарною практикою
його називати саме тим іменем з якою 
властивістю він працює, але вже без #.
7. Далі ставимо круглі дужки, потім
фігурні дужки.
8. Тобто синаксис аалогічий методу, 
за винятком, що перед назвою пишемо
ключове слово get.
9. Геттер існує для того, щоб 
повертати значення властивості.
10. Як можна скористатися геттером?
11. І тут друга відмінність. Незважаючи на
те, що це по факту метод, користуватися ним
потрібно, як звичайною властивістю, без 
круглих дужок і #.
12. Тобто пропишемо bmw.price у нас відпрацює
геттер і отримаємо результат 70000.

13. Для створея сеттера потрібно прописати
ключове слово set, далі його назву, аналогічну 
властивості з якою будемо взаємодіяти, і обовязково
потрібно у круглих дужках передати параметр, який 
буде приймати вхідні дані, на які будуть
змінювтися поточні дані, після цього 
прописати фігурні дужки.
14. Якщо це сеттер, то це означає, що в його тілі 
буде змінюватися значення.
15. З сеттером аналогічно працюємо, як зі звичайною
властивістю, тобто якщо потрібно змінити приватну
властивість price і щось туди прсвоїти, то потрібно 
з допомогою знаку присвоєння прописати наступне
bmw.price = 75000
16. Тобто, за рахунок цього синиаксису буде
автоматчно відпрацьовувати або геттер, або сеттер.
17.Якщо ми звертаємося до приватної властивості
через крапку, то відпрацьовує геттер
18. Якщо є знак присвоєння, то запускається сеттер
і виконається дія, яка є в його тілі.
19. І великий плюс сеттера в тому, що оскільки він
є методом, то в його тілі ми можемо використовувати
конструкції if і робити певні додаткові перевірки. 
*/ 

// class Car {
// 	#price;

// 	constructor(obj = {}) {
// 		this.brand = obj.brand;
// 		this.model = obj.model;
// 		this.#price = obj.price;
// 	}

// 	getModel(){
// 		return this.model
// 	}

// 	get price() {
// 		return this.#price;
// 	}

// 	set price(newPrice) {
// 		if(typeof newPrice !== "number") {
// 			console.log("Invalid data");
// 			return;
// 		}
// 		this.#price = newPrice;
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7",
// 	price: 70000
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5"
// });

// bmw.price = "75000";
// bmw.price = 75000;

// console.log(bmw.price); // 75000

// --------------------------------------

// Приватний метод

/* 
1. Метод може бути приватним в тому
випадку, якщо його використання ззовні не
має жодного сенсу. Тобто цей метод потрібний
для внутрішньої взаємодії і ми будемо його
використовувати тільки всередині нашого класу. 
2. Для того, щоб зробити приватний метод 
потрібно поставити # і записати його назву,
потім круглі дужки, після фігурні.
3. Метод буде приймати дані data і тип type, 
якому ці дані мають відповідати.
4. В тілі методу власне і зробимо перевірку.
5. Звернення до приватного методу аналогічне
зверненню до звичайного методу з допомогою this.
6. У метод передамо нову вартість, яку ми 
отримали у сеттері, як параметр, і тип, якому
ця вартість має відповідати.
7. Цей приватний метод буде здійснювати перевірку
чи відповідає тип даних, які до нас прийшли 
типу number, і в результаті буде повертати true 
або false.

8. Як це буде відбуватися?
9. Коли ми захочемо змінити нашу вартість, то 
автоматично запуститься сеттер, який прийме 
параметром нову ціну.
10. Далі ми порапляємо в тіло сеттера, де 
відбудеться наступна перевірка.
11. Обєкт, який привязаний контекстом до сетера
викличе приватний метод #checkType, який приймає
в себе два аргументи, нову вартісь і зразок типу
даних, відносно якого буде здійснюватися перевірка.
12. Отже ми йдемо у місце, де приватний метод
#checkType було створено і у його тілі здійснюється 
перевірка чи тип даних нової вартості не дорівнює
типу, який ми маємо, як зразок. Якщо не дорівнює
метод повертає false, в іншому випадку true.
13. Далі результат перевірки повертається до сеттера,
якщо повернеться true, то ми потрапимо у тіло if і 
відбудеться зміна вартості на нову і припиниться 
виконання методу, або якщо повернеться false, то 
у консоль виведеться рядок "Invalid data".

Висновок. 
Приватну властивість роблять ізольованою для того,
щоб нічого в коді не зламати, і за допомогою 
сеттера цю властивіть можна змінювати, 
перевіривши ї тип.
Приватний метод теж роблять ізольованим, коли 
використання його назовні класу недоцільне і його
треба використовувати всередині класу для певних
внутрішніх обчислень.
*/ 

// class Car {
// 	#price;

// 	constructor(obj = {}) {
// 		this.brand = obj.brand;
// 		this.model = obj.model;
// 		this.#price = obj.price;
// 	}

// 	getModel(){
// 		return this.model
// 	}

// 	get price() {
// 		return this.#price;
// 	}

// 	set price(newPrice) {
// 		if(this.#checkType(newPrice, "number")) {
// 			this.#price = newPrice;
// 			return;
// 		}
// 		console.log("Invalid data");
// 	}

// 	#checkType(data, type) {
// 		if(typeof data !== type) {
// 			return false;
// 		}
// 		return true;
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7",
// 	price: 70000
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5"
// });

// bmw.price = "75000";
// bmw.price = 75000;

// console.log(bmw.price); // 75000

// ---------------------------------------

// Статичні властивості і методи

/* 
1. Статичні властивості і методи це такі дані,
які не передаються в наш екземпляр обєкта.
2. Вони будуть існуваи тільки у класі Car і 
не будуь доступні екземплярам
3. Створюємо статичну властивість за допомогою
ключового слова static і присвоюємо їй значення.
4. Створимо статичний метод, який буде відповідати 
за те, що буде збільшувати статичну властивість qty.
5. Пишемо ключове слово static і назву методу.
6. Цей метод під час створення нового екземпляра 
класу повинен властивість qty збільшувати.
7. Властивість qty буде жити тільки в класі Car.
8. Якщо ця властивість доступна тільки класу і не 
доступна екземплярам класу, то до цієї властвості
можна звертатися через назву класа Car і кожного
разу збільшувати її на 1.
9. Щоб статичний метод increment відпрацьовував
кожного разу, коли створюється новий екземпляр
класу, його потрібно викликат у конструкторі.
10. До статичних властивостей ми звертаємося
через назву класу.
11. Консруктор запускається автоматично під час 
створея екземпляру класу
*/  

// class Car {
// 	#price;

// 	static qty = 0;

// 	static increment() {
// 		Car.qty += 1
// 	}

// 	constructor(obj = {}) {
// 		this.brand = obj.brand;
// 		this.model = obj.model;
// 		this.#price = obj.price;
// 		Car.increment();
// 	}

// 	getModel(){
// 		return this.model
// 	}

// 	get price() {
// 		return this.#price;
// 	}

// 	set price(newPrice) {
// 		if(this.#checkType(newPrice, "number")) {
// 			this.#price = newPrice;
// 			return;
// 		}
// 		console.log("Invalid data");
// 	}

// 	#checkType(data, type) {
// 		if(typeof data !== type) {
// 			return false;
// 		}
// 		return true;
// 	}
// }

// const bmw = new Car({
// 	brand: "BMW",
// 	model: "X7",
// 	price: 70000
// });

// const bmw1 = new Car({
// 	brand: "BMW",
// 	model: "X5",
// 	price: 65000
// });

// console.log(Car.qty); // 2

// ----------------------------------------

// ====================================== 2

/**
 * Наслідування класів
 * 
 * - extends
 * - Конструктор дочірнього класу (super)
 * - Методи дочірнього класу
 */

/* 
Для чого потрібне наслідування класів?

Наслідування класів дозволяє створити класи
зі спільними властивостями і методами, а потім у 
інших класів наслідувати ці властивості і методи, 
тобто використовувати їх в інших класах

Як це відбувається?

1. Створимо клас Hero.
2. У класі створимо конструктор
3. В конструкторі будемо приймати обєкт
певних параметрів.
4. В тілі конструктора будемо казати, щоб
конструктор створював у екземплярі властивість
this.name, в якій буде зберігатися obj.name, і ще 
одну властивість this.xp, в якій буде зберігатися 
obj.xp, тобто було створено дві властивості
4. Далі створимо спільний метод gainXp(), який 
буде наслідуватися кожному герою.
5. Зробимо кожного персонажа окремо.
6. Створимо клас Warrior, який буде успадковувати
властивості і методи з класу Hero.
7. Для цього після назви класу Warrior пишемо
ключове слово extends і імя класу з якого щось 
потрібно успадкувати.
8. Створимо екземпляр класу Warrior під назвою arthas
і додамо деякі властивості.
9. Обєкт arthas ми отримаємо у конструкторі 
класа Warrior.
10. Конструктор як параметр прийме літерал обєкта, де 
буде назва властивостей.
11. У цих властивостях буде зберігатися значення ключів
з обєкту arthas.
12. Потрібно передати класу Hero, від якого успадковуємося
передати набір даних, а саме обєкт з власивістю name і xp.
13. Для того, щоб з класу Warrior передати в клас, від 
якого ми успадковуємося, тобто Hero, певні дані, я повинен 
викликати спеціальний метод super()
14. В цей метод предаються ті дані, які хоче отримати
клас Hero.
15. Тепер Hero, під час створення екземпляру, також 
отримає потрібні йому дані.
16. Також створимо властивість, яка буде унікальною
для Warrior під назвою weapon.
17. За допомогою методу super(), який ми викликаємо
у кострукторі ми передаємо в клас Hero, від якого 
ми успдковуємося потрібні йому дані.
18. Зробимо метод для нашого воїна attack().
19. Створимо ще один клас

Висновок.
Суть в тому, щоб винести повторювані властивості і 
методи в окремий клас Hero, успадкуватись від нього і
в конструкторі з допомогою методу super() передати
йому необхідні дані. 
*/  

// class Hero {
// 	constructor(obj) {
// 		this.name = obj.name;
// 		this.xp = obj.xp;
// 	}

// 	gainXp(amount) {
// 		console.log(`${this.name} received ${amount} xp`);
// 		this.xp += amount;
// 	}
// }

// class Warrior extends Hero {
// 	// constructor({ name, xp, weapon }) {
// 	// 	super({ name, xp });
// 	// 	this.weapon = weapon;
// 	// }
// 	constructor(obj) {
// 		super({ name: obj.name, xp: obj.xp });
// 		this.weapon = obj.weapon;
// 	}

// 	attack() {
// 		console.log(`${this.name} attack with ${this.weapon}`);
// 	}
// }

// const arthas = new Warrior({
// 	name: "Arthas",
// 	xp: 1000,
// 	weapon: "Sword"
// });

// console.log(arthas);
// arthas.attack();
// arthas.gainXp(100);
// console.log(arthas);

// class Mage extends Hero {
// 	// constructor({ spells, ...param }) {
// 	// 	super(param);
// 	// 	this.spells = spells;
// 	// }
// 	constructor(obj) {
// 		super({
// 			name: obj.name,
// 			xp: obj.xp
// 		});
// 		this.spells = obj.spells;
// 	}

// 	cast() {
// 		console.log(`${this.name} is casting spells ${this.spells[0]}`);
// 	}
// }

// const khadgar = new Mage({
// 	name: "Khadgar",
// 	xp: 500,
// 	spells: ["fireball"]
// });

// khadgar.gainXp(100);
// khadgar.cast();
// console.log(khadgar);

// ----------------------------------------

// ========================================= 3

/**
 * Напиши клас Blogger для створення об'єкта
 * блогера з наступними властивостями:
 * - email - пошта, рядок
 * - age - вік, число
 * - numberOfPosts - кількість постів, число
 * - topics - масив тем на яких спеціалізується блогер
 *
 * Клас чекає один параметр - об'єкт налаштувань
 * з однойменними властивостями.
 *
 * - Додай метод getInfo(), який, повертає рядок: 
 *    User ${email} is ${age} years old and has ${numPosts} posts.
 * 
 * - Додай метод updatePostCount(value), який у параметрі value 
 *    приймає кількість постів, які потрібно додати користувачеві.
 */

// class Blogger {
// 	constructor(obj) {
// 		this.email = obj.email;
// 		this.age = obj.age;
// 		this.numberOfPosts = obj.numberOfPosts;
// 		this.topics = obj.topics;
// 	}

// 	getInfo() {
// 		return `User ${this.email} is ${this.age} years old and has ${this.numberOfPosts} posts.`
// 	}

// 	updatePostCount(value) {
// 		this.numberOfPosts += value;
// 	}
// }

// const kate = new Blogger({ // kate.constructor()
// 	email: "kate@gmail.com",
// 	age: 24,
// 	numberOfPosts: 20,
// 	topics: ["tech", "gaming"]
// });

// kate.updatePostCount(15);

// console.log("kate", kate.getInfo());

// const petya = new Blogger({
// 	email: "petya@gmail.com",
// 	age: 30,
// 	numberOfPosts: 17,
// 	topics: ["health", "sport"]
// });

// petya.updatePostCount(5);

// console.log("petya", petya.getInfo());

// ------------------------------------------

// ======================================== 4

/**
 * Напиши клас User який створює об'єкт 
 * із властивостями login та email.
 * Оголоси приватні властивості #login 
 * та #email, доступ до яких зроби через
 * гетер та сетер login та email.
 */

// class User {
// 	#login;
// 	#email;

// 	constructor(obj) {
// 		this.#email = obj.email,
// 		this.#login = obj.login
// 	}

// 	get login() {
// 		return this.#login;
// 	}

// 	set login(newLogin) {
// 		if(!newLogin) {
// 			console.log("Invalid data");
// 			return;
// 		}
// 		this.#login = newLogin;
// 	}

// 	get email() {
// 		return this.#email;
// 	}

// 	set email(newEmail) {
// 		this.#email = newEmail;
// 	}
// }

// const alice = new User({
// 	login: "Alice", 
// 	email: "alice@gmail.com"
// });

// alice.login = "Super Alice";

// console.log("Alice", alice.login);

// const yura = new User({
// 	login: "Yura", 
// 	email: "yura@gmail.com"
// });

// yura.email = "superyura@gmail.com"

// console.log("Yura", yura.email);

// ------------------------------------------