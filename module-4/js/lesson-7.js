"use strict";

// ============================= 1

/**
 * Об'єкти
 *
 * - Створення об'єкта
 * - Вкладені властивості
 * - Доступ до властивостей через крапку
 * - Доступ до вкладених властивостей
 * - Доступ до властивостей через квадратні дужки
 * - Зміна значення властивостей
 * - Додавання властивостей
 */

// Що таке об'єкт? Навіщо він нам потрібен?

// Для того, щоб створити обєкт ставимо фігурні дужки {},
// які ще називаються літерал обєкта.
// Для того, щоб ми могли наш обєкт наповнити контентом ми
// повинні дотримуватися певної структури. Обєкт зберігає в
// собі певні властивості, якщо їх декілька, то вони
// розділяються комою.
// Властивість обовязково складається з пари: ключ: значення.
// Ключ і значення розділяються двокрапкою.
// Ключ - це імя властивості і це зазвичай рядок.
// Значенням властивості можуть бути будь-які типи: примітиви,
// масиви, обєкти, булі, функції тощо.

// const playlist = {
//   // ключ: значення
//   name: "My playlist",
//   // ключ: значення
//   rating: 5,
//   // ключ: значення
//   tracks: ["track_1", "track_2", "track_3"],
//   isFavorite: true,
// };

// console.log(playlist);

// const user = {
//   // ключ: значення
//   name: "Jacques Gluke",
//   // ключ: значення
//   tag: "jgluke",
//   // ключ: значення
//   location: {
//   // ключ: значення
//     country: "Jamaica",
//     city: "Ocho Rios",
//   },
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };

// =============== Доступ до вкладенних властвостей.

// 1 спосіб. Доступ через крапку.

// З обєкта можна витягати конкретні значення.
// Для цього потрібно звернутися до обєкта,
// тобто до змінної в якій зберігається обєкт,
// і за допомогою крапки викликати певну властивість,
// прописавши імя ключа цієї властивості і в
// результаті отримати значення цієї властивості.
// Якщо ключа в обєкті не існує, то
// повернеться undefined.

// const playlist = {
//     // ключ: значення
//     name: "My playlist",
//     // ключ: значення
//     rating: 5,
//     // ключ: значення
//     tracks: ["track_1", "track_2", "track_3"],
//     isFavorite: true,
//   };

// console.log(playlist.name);
// // поверне рядок "My playlist"
// console.log(playlist.rating); // поверне 5
// console.log(playlist.cost); // поверне undefined

// 2 спосіб. синтаксис квадратних дужок[]

// Цей спосіб полягаєв тому, що імя ключа може бути
// заздалегідь невідоме, і він може приходити до нас
// в результаті певних дій, і зберігатися в змінній.
// В таких випадках використовується синтаксис
// квадратних дужок.
// Для того, щоб звернутися не безпосередньо до назви
// ключа, який зберігається в змінній, та використати
// значення, яке зберігається в змінній,
// використовується синтаксис квадратних дужок.

// const playlist = {
//   // ключ: значення
//   name: "My playlist",
//   // ключ: значення
//   rating: 5,
//   // ключ: значення
//   tracks: ["track_1", "track_2", "track_3"],
//   isFavorite: true,
// };

// const myKey = "rating";

// console.log(playlist.myKey);
// // поверне undefined, оскільки ключа з таким
// // імям myKey в обєкті playlist немає.

// //          playlist.rating
// console.log(playlist[myKey]);
// // поверне 5, оскільки за допомогою такого
// // синтаксису, замість [myKey] підставиться
// // значення змінної myKey, а саме "rating".
// // І в результаті відбудеться доступ в обєкті
// // playlist до ключа властивості rating, і
// // отримаємо значення властивості число 5.

// 3 спосіб. [""] Хардкод

// const playlist = {
//   // ключ: значення
//   name: "My playlist",
//   // ключ: значення
//   rating: 5,
//   // ключ: значення
//   tracks: ["track_1", "track_2", "track_3"],
//   isFavorite: true,
// };

// const myKey = "rating";

// console.log(playlist["rating"]);
// // поверне 5, оскільки в квадратні дужки можна
// // безпосередньо вставляти значення зі змінної.

// Висновки
// Якщо ми знаємо назву ключа властивості, то
// ми звертаємося через крапку, щоб отримати доступ
// значення властивості.
// Якщо ні, то використовуємо квадратні дужки.

// =============== ЗМІНА ЗНАЧЕННЯ ВЛАСИВОСТЕЙ

// В обєкті можливо перезаписувати дані певних
// властивостей. Для цього потрібно звернутися
// до обєкта, де потрібно щось перезаписати,
// поставити крапку і звернутися до властивості
// значення, якої потрібно перезаписати. Далі
// потрібно присвоїти нове значення, яке потрібно
// перезаписати.

// Незалежно від того, що обєкт створений за
// допомогою ключового слова const, ми змінюємо
// не назву змінної обєкта, а змінюємо вкладені
// в нього властивості, які можна
// переініціалізовувати, і помилки в консолі не буде.

// const playlist = {
//   // ключ: значення
//   name: "My playlist",
//   // ключ: значення
//   rating: 5,
//   // ключ: значення
//   tracks: ["track_1", "track_2", "track_3"],
//   isFavorite: true,
// };

// console.log(playlist.rating); // поверне 5

// playlist.rating = 4; // перезаписуємо значення

// console.log(playlist.rating); // поверне 4


// ==================== Додавання властивостей

// В обєкті можна додавати нові властивості, 
// навіть якщо їх не було в обєкті.
// Для того, щоб додати нову властивість до 
// обєкта потрібно звернутися до обєкту за
// назвою змінної і за допомогою крапки 
// написати нову назву (ключ-імя) властивості
// Після того, потрібно происвоїти за
// допомогою оператора присвоєння нове значення,
// яке потрібно зберегти у новій властивості 
// обєкта.

// const playlist = {
//   // ключ: значення
//   name: "My playlist",
//   // ключ: значення
//   rating: 5,
//   // ключ: значення
//   tracks: ["track_1", "track_2", "track_3"],
//   isFavorite: true,
// };

// playlist.rating = 4; // перезаписуємо значення
// playlist.newProp = "new value";

// console.log(playlist); 
// поверне обєкт, де буде присвоєна нова властивість.

// Синтаксис переприсвоєння і додавання нових
// властивостей до обєкта однакові.
// Тобто, якщо ми звертаємося до обєкта, до 
// його якоїсь властивості і в моєму обєкті
// є така властивість, то значення в неї 
// перезапишеться.
// Якщо ми звертаємось до обєкта, до якоїсь
// властивості, якої в нього немає, то ця 
// властвість буде створена і в неї запишеться
//  значення, яке ми сюди присвоїли.
// Тобто ситуація подібна до змінних, коли в 
// них потрібно переприсвоїти значення.

// В обєкті можуть зберігатися інші обєкти.
// Як можна отримати доступ до вкладених
// властивостей обєкта?
// До вкладених властивостей обєкта отримуємо
// доступ через крапку.
// Якщо потрібно переініціалізувати вкладені
// властивості звертаємося до властивості через 
// крапку і присвоюємо нове значення

// const user = {
//   username: "Alice",
//   skills: {
//     html: true,
//     css: true,
//     js: false
//   }
// }

// user.skills.js = true; 
// // переписав значення властивості 

// const obj = user.skills;

// console.log(user);

// =================================== 2

/**
 * Об'єкти
 * 
 * - Тип даних за посиланням
 * - Масиви і функції - це об'єкти
 */

// Об'єкти - це складний тип даних.
// Масив - це об'єкт певного виду. 
// Функції - це також об'єкти


// Так робити не потрібно.
// Не можна додавати елементи до масиву
// таким чином.

// const arr = [1, 2, 3];

// arr.hello = "hi";

// console.log(arr); // [1, 2, 3, hello: 'hi']

// function foo() {
//   console.log("lalala");
// }

// foo.hello = "hi";

// console.dir(foo);

// dir означає подивитися у форматі обєкту, 
// розгорнути як обєкт.

/**
 * Як себе поводять обєкти під час того,
 * як ми їх створюємо, зберігаємо і
 * копіюємо, ініціалізуємо один обєкт в інший
 */

// const a = { x: 1, y: 2 }
// const b = a;

// console.log(a === b); // true

// Що тут відбувається?
// Насправді з обєктами та сама історія, що і 
// з масивами. Це складний тип даних, він 
// копіюється за посланням, і коли ми створюємо
// обєкт, то у нас в памяті створюється ячейка, 
// в яку цей обєкт складається і в змінну (а)
// передається на нього посилання.
// Коли ми в нашу змінну (b) ініціалізуємо
// значення змінної (а) відбувається наступне:
// в змінну (b) буде зберігатися посилання на 
// той самий обєкт, який був збережений у 
// змінну (а). Посилання, не значення цього обєкта,
// а саме посилання на нього. І коли в нас 
// відбувається порівняння a === b, то порівнюються 
// посилання цих змінних. Якщо вони посилаються на 
// один і той самий обєкт, то поверне true.
// Тут все по аналогії з масивами.

// b.x = 100;
// a.hello = "world";

// console.log("a", a); // a {x: 100, y: 2}
// console.log("b", b); // b {x: 100, y: 2}


// Що тут вібувається?
// Я звертаюсь до обєкта b, за посиланням
// знаходжу мій обєкт, знаходжу його властвість x
// і присвоюю туди значення 100. Але оскільки наш
// обєкт (а) так само посилається на те саме місце
// в памяті, то зміни ми побачимо і в обєкті (а) 
// і в обєкті (b). По факту змінюється не локально,
// а віддалено десь в памяті. Аналогічна історія
// a.hello, зміни відбудуться в обох обєктах.

// const a = {x: 1, y: 2}
// const b = {x: 1, y: 2}

// console.log(a === b); // false


// І виходячи з цього, можна зробити наступний
// висновок, що якщо я створю змінну (а), яка буде 
// зберігати в собі якийсь обєкт, і створю змінну (b),
// яка буде зберігати в собі якийсь обєкт і спробую
// ці обєкти порівняти, то отримаю false, тому що 
// обєкти порівнюються за посиланням. Однакові обєкти 
// за властвостями можуть не дорівнювати один одному, 
// так само як і масиви, оскільки порівнюються за 
// посиланням, а не за значенням.
// І якщо у нас дві змінні, посилаються на один і 
// той самий обєкт, то переініціалізація однієї 
// змінної буде приводити до зміни значення в іншій.  

// const a = {x: 1, y: 2}
// const b = {x: 1, y: 2}

// //            1 === 1
// console.log(a.x === b.x); // true

// У цьому випадку прівнюються значення властивості
// обєкта, які є примітивами (a.x поверне число), а 
// примітиви порівнюються за значенням.
// Отже у виразі буде true 

// На співбесіді можуть запитати чому один обєкт не
// дорівнює іншому, тому що вони порівнюються за 
// посиланням. Масиви - аналогічно.



/**
 * Об'єкти
 * 
 * - Короткі властивості
 * - Обчислювальні властивості
 */

// const username = "Alice";
// const age = 25;

// Потрібно створити обєкт на основі цих даних

// const newUser = {
//   username: username,
//   age: age,
// }

// console.log(newUser);

// Але, якщо ми хочемо в обєкті створити 
// властивість, назва ключа якого співпадає 
// з назвою змінної, значення якої ми хочемо 
// в цей ключ передати, то в цьому випадку 
// можна використати короткі властивості

// const newUser = {
//   username,
//   age,
// }

// console.log(newUser);

// Що відбудеться в цій ситуації?
// Створиться ключ username і в нього 
// збережеться значення, яке зберігається 
// в змінній username, з ключем age -
// та сама ситуація. Частіше цей 
// синтаксис використовують у функціях.
// Якщо назва ключа і назва змінної однакові, 
// то користуємося короткими властивостями, 
// тобто не ставимо двокрапку і не пишемо
// назву змінної ще раз.

// function foo(name, age) {
//   return {
//     name,
//     age
//   }
// }

// console.log(foo("Kane", 15));


// ============== Обчислювальні властивості

// В обчслювальних властивостях використовується 
// синтаксис квадратних дужок.
// Цей спосіб використовується, якщо ми не знаємо
// назву ключа або вона зберігається в якійсь 
// змінній, або є динамічною, тоді використовується
// синтаксис квадратних дужок. Тобто витягуємо ключ,
//  якого ще нема або назва невідома

// Є змінна inputName, в якій зберігається
// значення рядок color. Потрібно створити
// обєкт, в якому зберегти ключ, який буде 
// відповідати значенню, яке зберігається
// в змінній inputName.

// const inputName = "color";
  
// const obj = {
//   // inputName: "red",
//   // створиться нова властивість з ключем
//   // inputName, а нам потрібно ключ, 
//   // значення якого зберігається в 
//   // змінній inputName.

//   // color: "red"
//   [inputName]: "red",
//   // Для того, щоб в обєкті замість ключа
//   // підставлялось значення змінної inputName,
//   // потрібно в обєкті використати синтаксис
//   // квадратних дужок, в яких записати назву
//   // змінної, яку потрібно використати, 
//   // потім поставити двокрапку, і записати 
//   // значення яке потрібно присвоїти.
// }

// console.log(obj);

// Інший приклад

// Потрібно в обєкті створити ключ, який буде
// відповідати значенню, яке зберігається в 
// змінній параметра key. 
// Як це можна зробити?
// Оскільки потрібно створити в обєкті не новий 
// ключ key, а ключ, який зберігає значення, 
// яке є в параметрі key, то тут використовуємо
// синтаксис квадратних дужок. За рахунок 
// квадратних дужок створиться ключ, який буде 
// відповідати значенню, яке буде збережено
// в параметрі key. 

// function createObj(key, value) {
//   const obj = {};
//   obj[key] = value;
//   return obj;
// }

// console.log(createObj("name", "Kate"));

// Коротший аналогічний спосіб за допомогою
// обчислювальних властивостей.

// Тут використовується значення, яке лежить
// в параметрі key. У квадратних дужках 
// можна використовувати методи рядків.

// function createObj(key, value) {
//   return {
//     [key.toLowerCase()]: value,
//   }
// }

// console.log(createObj("nAme", "Kate"));


// ========================== 4

/**
 * Перебір об'єкта
 * 
 * - Цикл for...in
 * - Метод Object.keys
 * - Метод Object.values
 */

// ============= Цикл for...in

// Обєкт - це неітерова сутність.
// Ми не можемо проходитися по ньому так, 
// як ми це робимо по масивах за допомогою
// циклів for, for...of. Так не працює.

// Для обєкта є спец. цикл, який дає 
// можливість перебирати обєкт, тобто 
// отримувати ключі обєкта. Він
// називється for...in

// Розглянемо перший спосіб

// Переберемо на обєкт за допомогою
// циклу for...in
// Принцип роботи той самий, що і в циклі 
// for...of для масивів.

// Як його створюємо
// 1. Пишемо ключове слово for, потім ставимо
// круглі дужки () після них фігурні дужки {}.
// 2. В умові створюється змінна 
// (назва змінної довільна) за допомогою
// ключового слова const, далі ключове слово in
// і назву обєкта, який потрібно перебрати.
// 3. Що буде зберігатися у змінній key?
// В змінній key зберігаються імена ключів з обєкту,
// який перебирається.
// 4. Що далі?
// Значення ключа буде зберігатися в змінну key
// на кожній ітерації циклу.
// 5. Як можна отримати значення властивості 
// обєкту feedback, якщо значення властивості
// зберігається в змінній key?
// За допомогою синтаксису квадратних дужок,
// оскільки ми не знаємо назви ключів. В змінній
// key зберігається значення, якщо нам потрібно 
// підставити значення, яке зберігається в змінній,
// ми використовуємо синтаксис квадратних дужок.
// 6. Щоб порахувати суму потрібно до total додати
// значення, яке зберігається в змінній key.

// const feedback = {
//   good: 5,
//   neutral: 10,
//   bad: 3,
// }

// let total = 0;

// for(const key in feedback) {
//   // console.log(feedback[key]); 
//   // // значення, яке зберігається в key

//   total += feedback[key];
// }
// console.log(total);


// Розглянемо другий спосіб

// Метод Object.keys.

// 1. Створимо змінну з довільною назвою keys.
// 2. Звернемося до глобальної сутності Object,
// яка просто існує.
// 3. Далі ставимо крапку і викликаємо в неї 
// метод keys(), у якого обовязково присутні
// круглі дужки, тобто це функція.
// 4. Як аргумент у круглих дужках цього методу
// передається обєкт.
// 5. Метод Object.keys під час виклику поверне 
// масив ключів обєкта, який був переданий 
// як аргумент.
// 6. Якщо є масив, то його можна перебрати
// за допомогою циклу for...of.
// 7. Значення ключів зберігається в 
// змінній key.
// 8. Як можна дістати з обєкту значення,
// яке зберігається під ключем захованим в 
// змінній key? Це можна зробити за 
// допомогою синтаксису квадратних дужок.

// Висновок
// На відміну від попереднього прикладу 
// спочатку отримали масив ключів, а потім цей
// масив перебрали за допомогою циклу for...of 

// const feedback = {
//   good: 5,
//   neutral: 10,
//   bad: 3,
// }
// let sum = 0;

// const keys = Object.keys(feedback);

// for(const key of keys) {
//   sum += feedback[key];
// }

// console.log(sum);


// Розглянемо другий спосіб

// Метод Object.values

// 1. Створимо змінну з довільною назвою values.
// 2. Звернемося до глобальної сутності Object,
// яка просто існує.
// 3. Далі ставимо крапку і викликаємо в неї 
// метод values(), у якого обовязково присутні
// круглі дужки, тобто це функція.
// 4. Як аргумент у круглих дужках цього методу
// передається обєкт.
// 5. Метод Object.values під час виклику поверне 
// масив значень обєкта, який був переданий 
// як аргумент.
// 6. Якщо є масив, то його можна перебрати
// за допомогою циклу for...of.
// 7. item буде кожне значення масиву і його
// можна одразу додавати до змінної sum.

// const feedback = {
//   good: 5,
//   neutral: 10,
//   bad: 3,
// }
// let sum = 0;

// const values = Object.values(feedback);
// console.log(values);

// for(const item of values) {
//   sum += item;
// }

// console.log(sum);


// Висновки

// Пріоритетніше з цих трьох способів 
// використовувати спосіб з методом
// Object.keys()
// 1. отримувати ключі обєкта
// 2. далі вже перебирати ключі
// як звичайний масив.
// Це може запобігти певним
// неочікуваним результатам.



// ================================= 5

/**
 * Напиши скрипт, який для обєкта user, послідовно:
 * - додає поле mood зі значенням "happy"
 * - замінює значення hobby на "skydiving"
 * - замінює значення premium на false
 * - виводить вміст обєкта user у форматі 
 * ключ:значення використовуючи Object.keys()
 * та for...of
 */

// const user = {
//   name: "Alice",
//   age: 20,
//   hobby: "html",
//   premium: true
// };

// user.mood = "happy";
// user.hobby = "skydiving";
// user.premium = false;

// const keys = Object.keys(user);

// for(const key of keys) {

//   console.log(`${key}: ${user[key]}`);

// }

// В параметр функції прийшло посилання
// на змінений обєкт, адже обєкти 
// копіюються і передаються за посланням.
// Внаслідок цього всі дії, які ми з обєктом
// виконуємо будуть виконуватися в памяті, 
// де він знаходиться і як наслідок наш обєкт 
// також буде змінений.

// const user = {
//   name: "Alice",
//   age: 20,
//   hobby: "html",
//   premium: true
// };

// function foo(obj) {
//   obj.mood = "happy";
//   obj.hobby = "skydiving";
//   obj.premium = false;

//   const keys = Object.keys(obj);

//   for(const key of keys) {
//     console.log(`${key}: ${obj[key]}`);
//   }
// }

// foo(user);
// console.log(user);

// return потрібен для того, щоб повертати
// результат виконання функції у місце
// її виклику.
// Якщо return немає або справа від нього 
// нічого не записано, то повернеться 
// undefined.


/**
 * У нас є обєкт, де зберігаються зарплати
 * нашої команди. Напишіть код для сумування
 * всіх зарплат і збережіть результат у змінній
 * sum. Повинно вийти 390. Якщо обєкт salaries
 * порожній, то результат має бути 0.
 */

// const salaries = {
//   John: 100,
//   Ann: 160,
//   Pete: 130,
// }

// function getSumSalaries(objSalaries) {
//   let sum = 0
//   const keys = Object.keys(objSalaries);
//   // Object.values витягає значення з обєкту
//   // Object.keys витягає ключі з обєкту
//   // в обох випадках перетворює в масив
//   for(const key of keys) {
//     sum += salaries[key];
//   } 
//   return sum;
// }

// console.log(getSumSalaries(salaries));

// ==================== Розбір питань

// Якщо потрібно створити в obj нову властивість
// це можна зробити двома способами
// 1. Через крапку сказати obj.name і зберегти 
// сюди значення "Kate".
// 2. Але, якщо значення ключа зберігається в 
// якійсь змінній, то потрібно використати
// синтаксис квадратних дужок.

// const inputName = "color";

// const obj = {};

// // 1 спосіб через крапку
// obj.name = "Kate";

// // 2 спосіб квадратні дужки.
// // Тобто буквально тут говориться наступне.
// // Обєкт створи в собі ключ, значення якого 
// // зберігається в змінній inputName.

// //   color: "red"
// obj[inputName] = "red";

// console.log(obj);

// Та сама історія, якщо потрібно отримати
// значення

// Як можна отримати властивість з обєкту?
// Двома способами
// 1. Через крапку obj.color
// 2. Через квадратні дужки, якщо імя ключа
// невідоме і зберігається десь у змінній.

// const inputName = "color";

// const obj = {
//   color: "blue",
// };

// console.log(obj.color); // blue
// console.log(obj.inputName); // undefined 
// //          obj.color
// console.log(obj[inputName]); // blue


