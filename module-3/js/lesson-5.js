// ===================================== 1

/**
 * Масиви
 *
 * - Створення масиву
 * - Доступ до елементів
 * - Перевизначення значення елемента
 * - Довжина масиву
 * - Індекс останнього елемента
 * - Перевизначення
 */

// console.log(Number([])); // Повертає число 0

// Якщо масив який має одне значення, то повертає це значення.
// console.log(Number([5])); // Повертає число 5

// Якщо значенням буде рядок, але який ми можемо методом Number() перетворити на число, повертає число.
// console.log(Number(["5"])); // Повертає число 5

// Не може привести до числа.
// console.log(Number(["5px"])); // Повертає NaN

// Але якщо в масиві буде не одне значення, то поверне NaN.
// console.log(Number(["5", "3"])); // Повертає NaN

// const a = 5;

// a = 6; // буде помилка. перевизначати const не можна.
// // Коли у нас є знак "=" присвоєння, тоді ми перевизначаємо значення у нашій змінній, коли це можливо(напр. за допомогою ключового слова let).

// Що таке масив?
// Масив - це індексований список якихось елементів.

// Як створюється масив?

// const sourses = []; // порожній масив
// [] - це літерал масиву, за допомогою яких створюється масив.

// Масив можна наповнювати будь-якими типами данних(рядок, число, буль)
// Роздільником між нашими елементами в масиві виступає кома.
// Частіше за все наш масив зберігає в собі данні одного типу. Або числа, або рядки. Елементи з різними типами данних також можна покласти до масиву.

// const sourses = ["str", 5, true, undefined, null];
// // ['str', 5, true, undefined, null]
// console.log(sourses);

// Це масив рядочків.
// Замість того, щоб створювати цілу купу змінних, в яких мали зберігатися ці рядки, ми поклали ці рядки в одне місце, в масив.

// //                  0       1     2     3           4
// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// console.log(courses);

// Треба пам'ятати, що елементи, які знаходяться в масиві, є індексованими. Тобто у кожного елементу є свій індекс.
// Індекси починаються з нуля, як і в рядках.

// Навіщо мені ця інформація?
// Вона для того, щоб мати можливість отримувати конкретний елемент,
// знаючи його індекс.

// Синтаксис доступу до елементів масиву
// courses[indexElement];

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// console.log(courses[0]);

// Можна переприсвоювати нове значення для вкладених елементів масиву.
// Потрібно звернутися за індексом елемента і перевизначити значення елемента масиву.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// courses[2] = "Node.js";
// console.log(courses);
// // ["HTML", "CSS", "Node.js", "React", "Postgres"]

// // Якщо
// courses = []; // буде помилка

// Довжина масиву

// У масиві є властивість, яка дає можливість отримати довжину масиву.
// Властивість length число, яке є довжиною масива.
// За допомогою довжини масива можна визначити індекс останнього елемента масиву, незалежно від того наскільки довгий у нас масив.
// Індекс останнього елементу масиву завжди на 1 менший за довжину цього ж масиву.

// // індекс елем     0       1     2       3         4
// //порядок елем     1       2     3       4         5
// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const lastIndex = courses.length - 1;

// console.log(lastIndex); // Повертає 4
// console.log(courses.length); // Повертає 5
// console.log(courses[lastIndex]); // Повертає "Postgres"
// console.log(courses[courses.length - 1]); // Повертає "Postgres"

// =============================== 2

/**
 * Передача за посиланням і за значенням
 *
 * Примітиви і складні типи
 * Посилальна рівність (referential equality)
 */

// let a = 5;
// let b = a;

// b += 1;

// console.log("a", a); // 5
// console.log("b", b); // 6

// Чому так відбувається?
// Тому що, коли ми в нашу змінну b присвоїли змінну a, то в змінну b присвоїлось значення змінної a, і якій зберігається примітивний тип данних.
// Тобто, якщо ми наші змінні, в яких зберігається примітивний тип даних, переприсвоюємо в іншу змінну, то у нас відбувається копіювання за значенням.
// Тобто у цьому виразі let b = a; на місце значення змінної (a), піставляється значення, яке в ній зберігається (5) і буде let b = 5;, якщо це примітивний тип данних.
// Присвоюється саме значення.
// Потім якщо до змінної b додати 1, то вийде 6.
// А змінна a залишиться без змін (5). Та їй нема різниці, що ми робимо зі змінною b. a - окремо, b - окремо.
// Примітивні типи данних копіюються за значенням.

// const a = [1, 2, 3];
// const b = a;

// a[0] = 50;
// b[0] = 100;
// Навіть якщо ми змінимо нульовий індекс в b, то це саме значення також присвоїться в змінну (а)

// console.log("a", a); // [50, 2, 3]
// console.log("b", b); // [50, 2, 3]

// Що відбудеться?
// В обох змінних під нульовим індексом опиниться значення 50
// Чому так відбувається?
// Коли створив змінну (а) і присвоїв сюди масив відбулося наступне.
// 1. В памяті була створена окрема ячейка коробочка, куди було покладено цей масив.
// 2. Масив - це складний тип данних.
// 3. Тобто створили місце в памяті, поклали туди масив і
// 4. В нашу змінну (а) ми присвоїли посилання на цей масив.
// 5. Тобто, постланя на місце в памяті, де цей масив знаходиться.
// 6. Коли в змінну b присвоюється значення змінної (а), то оскільки в змінній (а) складний тип данних, на відміну від примітивів, туди буде присвоєне не значення, яке лежить в змінній (а), а буде присвоєне посилання на той самий масив, тобто на те саме місце в памяті, де лежить масив.
// 7. Тобто складні типи даних копіюються за посиланням.
// 8. Коли ми йдемо до змінної (а), тобто йдемо в память, де лежить масив і кажемо, що під нульовим індексом зміни значення на число 50.
// 9. Окей, змінили.
// 10. Далі що?
// 11. А змінна b посилається на те саме місце у памяті, що і змінна (а)
// 12. І тому ми змінили в одному місці ці данні, але посилається на них і змінна (а) і змінна b.
// Тобто ми не локально змінюємо дані, а одразу віддалено. І вони одразу стають доступими для всіх зміних, які мають посилання на це місце в памяті.

// // Порівняння масивів

// const a = [1, 2, 3];
// const b = a;

// console.log(a === b);
// // поверне true, оскільки масиви посилаються на одне місце в памяті

// // Коли порівнюються масиви, то вони порівнююься не за значенням, а за посиланням, яке вказує на місце в памяті

// const x = [1, 2, 3];
// const y = [1, 2, 3];

// console.log(x === y);
// Оскільки це різні масиви, хоча і вони мають в собі подібні значення, змінні мають різні посилання на місце в памяті, то вираз поверне false

// Висновки
// 1. коли ми намагаємося в якусь змінну (b) передати значення, яке зберігається в змінній (a), в якій зберігається складний тип данних (масив), то в змінну b буде передано посилання на цей масив.
// Масиви копіюються за посиланням
// 2. При порівнянні двох однакових масивів, навіть якщо у них є подібні значення, не дорівнюють один одному.
// Тому що, масиви порівнюються за посиланням, а не за значенням.

// =========================== 3

/**
 * Методи масиву
 *
 * - join
 * - split
 * - slice
 * - concat
 * - indexOf
 * - push/pop
 */

// Метод масиву - це функція, яка вбудована в масив і дає можливість виконувати якусь дію з цим масивом

// Метод join()

//Синтаксис
// join(аргумент)
// метод аргументом приймає рядок, який є розділювачем між елементами масиву.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];

// // const str = courses.join(" ");
// // console.log(str);
// // // поверне рядок "HTML CSS JS React Postgres"

// const str = courses.join("-");
// console.log(str);
// console.log("courses", courses);

// поверне рядок "HTML-CSS-JS-React-Postgres"

// Створюється змінна str за допомогою ключового слова const, в якій зберігається результат виконання методу join() над масивом courses.
// Для того, щоб викликати метод масиву ставиться крапка після масиву, який викликає метод. Оскільки це метод функція в синтаксі обовязково присутні круглі дужки, за допомогою яких він викликається (courses.join()).
// Метод join() перетворює масив, який викликає його, у рядок.
// А аргумент, який він приймає в себе, буде розділювачем між елементами  масиву
// Метод join() не змінює (не мутує) вихідний масив, який його викликав.
// Він просто виконав свою дію, повернув значення виконання (рядок) в місце свого виклику, який ми присвоїли в змінну str.
// Наш масив не змінився.

// Метод split()

// Синтаксис
// split(аргумент)
// метод аргументом приймає рядок, який є розділювачем між елементами масиву.

// Насправді метод split() зовсім не метод масиву, а метод рядка.
// Чому ми його розглядаємо?
// Тому що, метод join() і метод split() зазвичай використовують у зв'язці. Чому?
// Тому що, метод split() виконує діаметрально протилежну дію тому, що робить метод join().
// Якщо метод join() з масиву робить рядок, де розділювачем між елементами є аргумент, який він приймає в себе при виклику.
// То метод split() навпаки візьме і розіб'є мій рядок на елементи і складе їх в масив.
// Але розбивати на елементи метод split() буде за аргуметом, який він приймає у себе під час виклику.
// Якщо аргументом передати порожній рядок ("") метод split() розіб'є рядок по символам

// Висновки.
// Метод join() - з масива в рядок, split() - з рядка в масив.
// Або навпаки, ми можемо з рядка спочатку створити масив. Далі виконати якусь дію з кожним нашим елементом масиву, а потім назад запхати їх у рядок. Тобто послідовність може бути різною.
// Ці два методи можуть існувати окремо і використовуватись окремо, але дуже часто їх використовують у зв'язці.
// Також ці методи не змінюють (не мутують) наш вихідний масив

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];

// const str = courses.join(" ");
// console.log(str);

// const arr = str.split(" ");
// console.log(arr);

// const str = "hello world";
// const arr = str.split(" ");

// console.log(arr);

// Метод slice()

// Синтаксис
// slice(startIndex, endIndex);
// Перший аргумент - це індекс елемента, з якого потрібно почати вирізати шматок з масиву.
// Другий елемент - це індекс елемента, до якого не включно, я хочу вирізати.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const arr = courses.slice(0, 3); // поверне ['HTML', 'CSS', 'JS']

// console.log(arr);

// Що робить метод slice()?
// Метод slice() вирізає шматочок з масиву, який виклкав цей метод.
// Тобто буде виконано наступне. З масиву виріжеться елемент під 0, 1, 2 індексом, до третього не включно.
// Якщо буде не заданий другий аргумент методу slice(), а тільки перший, то метод  виріже шматок масиву, починаючи з індекса, який був заданий, як параметр при виклику, і до кінця масиву.
// При цьому вихідний масив залишається без змін.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const arr = courses.slice(3); // поверне ["React", "Postgres"]

// console.log(arr);

// // Якщо взагалі не передати жодного аргумента, то метод slice() створить копію масиву і збереже її в змінну arr.
// // Копію, не посилання, а новий масив покладе в нове місце пам'яті і збереже його в змінну arr.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const arr = courses.slice();
// // поверне ["HTML", "CSS", "JS", "React", "Postgres"]

// console.log(arr === courses);
// // false. різні масиви, лежать в різних місцях

// console.log(arr);

// // Метод slice() може приймати від'ємні значення, тобто буде вирізати шматочок з кінця масиву.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const arr = courses.slice(-3);

// console.log(arr); // поверне ['JS', 'React', 'Postgres']

// Метод concat()

// Синтаксис
// arr.concat(arr2)

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const arr = [1, 2, 3];
// const arr2 = [3, 2, 1];

// const newArr = courses.concat(arr, arr2);

// console.log(newArr);

// Що робить метод concat()?
// Цей метод дає можливість об'єднати декілька масивів в один масив.
// Як це вібувається?
// Викликається метод concat() у вихідному масиві, який буде об'єднуватися з іншими масивами.
// В методі concat(), як аргумент передається масив, який хочемо поєднати з вихідним масивом.
// В змінну newArr збереглося поєднання масивів courses і arr.
// Має значення послідовність, у якій передаються масиви як аргументи у методі concat(). В якій послідовності передадуться масиви як аргументи і який масив буде вихідним, в такій послідовності і будуть відображатися елементи у новому масиві.

// Метод indexOf()

// Синтаксис
// array.indexOf("")

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const index = courses.indexOf("React"); // 3

// console.log(index);

// Що робить метод indexOf()?
// Метод indexOf() шукає чи є в масиві елемент, який був переданий методу як аргумент.
// Якщо є, то поверне індекс цього елемента.
// Якщо такого елементу нема, то повертає -1.
// Регістр також має значення.
// Тобто шукає індекс елемента і повертає мені його, нема то -1.

// Метод push()

// Синтаксис
// arr.push("") - додає в кінець масиву, поверає довжину масиву

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const res = courses.push("Node.js");

// console.log("res", res); // поверне 6

// console.log(courses);
// // повертає ['HTML', 'CSS', 'JS', 'React', 'Postgres', 'Node.js']

// Що робить метод push()?
// Він додає в масив, який викликав цей метод, значення, яке було передано в метод push() як аргумент і додає його в кінець масиву.
// Результатом виклику методу push() буде довжина новоствореного масиву.

// Висновки
// Тобто метод push() додає в кінець масиву значення і повертає довжину новоствореного масиву.
// Метод push() змінює (мутує) вихідний масив.

// Метод pop()

// Синтаксис
// arr.pop("") - вирізає останній елемент масиву.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];
// const res = courses.pop();

// console.log(res); // поверне Postgres

// console.log(courses);
// // повертає ['HTML', 'CSS', 'JS', 'React']

// Метод pop() не потребує аргументів.
// Цей метод вирізає останній елемент масиву.
// Цей останній елемент, який він вирізав, він повертає.
// Метод pop() змінює (мутує) вихідний масив.

// ================================== 4

/**
 * Ітерація по масиву
 *
 * - Ітерація по масиву циклом for
 * - Метод includes
 * - Цикл for...of
 * - Різниця у використанні for і for...of
 */

// Якщо масив індексована сутність - це означає, що ми по ній можемо якось ітеруватись. Подібна ситуація як у рядочків.

// const friends = ["Rachel", "Monica", "Phoebe", "Joey", "Chandler", "Ross"];

// for (let i = 0; i < friends.length; i++) {
//   friends[i] += "!";
// }
// console.log(friends);

// Тепер давйте ми будемо ітеруватися по нашому масиву за допомогою циклу for
// 1. Створимо цикл for.
// 2. У циклі ініціалізуємо змінну (і), яка буде мати значення першого елемента масиву. Як ми знаємо індексація елементів масиву починається з нуля
// 3. Треба передати умову виходу з циклу. До яких пір я буду працювати у циклі? До тих пір поки у моєму масиві є елементи.
// 4. Для цього можна скористатися властивістю довжини масиву (friends.length).
// 5. У пост-виразі ми будемо змінювати змінну-лічильник на +1.
// 6. Потрібно вивести кожного друга в консоль.(friends[i])
// 7. і - відповідають індексам елементів масиву.
// 8. потрібно [i] для того щоб витягнути значення елементів з масиву за допомогою змінної-лічильника, яка при кожній ітерації буде змінюватся, відповідно будуть змінюватися і виводитися значення елементів масиву у консоль при кожній ітерції.
// 9. Також потрібно до кожного елемента додати "!"

// Цикл for... of
// Ще один спосіб для ітерування масивом

// const friends = ["Rachel", "Monica", "Phoebe", "Joey", "Chandler", "Ross"];

// for (const item of friends) {
//   console.log(item);
// }

// Що тут відбувається?
// Ми отримали той самий результат, що і в попередньому циклі, але тут зовсім інший синтаксис.

// В круглих дужках циклу for... of створюється змінна item, яка буде використовуватися і перестає існувати на кожній ітерації циклу.
// І прописується з якого масиву будуть братися елементи на кожній ітерації(friends).
// Для роботи цього циклу не потрібна змінна-лічильник і умова виходу. Цикл зробить це все сам під капотом.
// Цей цикл просто перебере всі елементи масиву від початку і до кінця і припинить свою роботу, якщо його не було перервано раніше.
// Різниця між цими циклами в тому, якщо нам не потрібен індекс елемента, ми можемо без проблем використовувати цикл for... of.
// Якщо потрібен індекс - використовуємо for.
