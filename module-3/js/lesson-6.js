// ========================================= 1


// Оператор нульвого злиття ??

// Спецільно створений для опрацювання null та undefined
// Він дуже схожий на логічний оператор ||, який шукає першу істину, яку знайшов.
// Оператор ?? шукає першу істину і повертає її
// Тобто undefined і null його не влаштовують, все інше влаштовує
// якщо буде разом null і undefined повертає останнє з цих значень 

// console.log(undefined ?? null); // повертає null
// console.log(null ?? undefined); // повертає undefined
// console.log(5 ?? undefined); // повертає 5
// console.log(null ?? 5); // повертає 5


/**
 * Псевдомасив arguments і Array.from
 */



// function foo() {
// // console.log(arguments);
// // console.log(arguments.length);
// // console.log(arguments.jon(" ")); // помилка
// const args = Array.from(arguments); // перетворення в масив
// console.log(Array.isArray(args)); // перевірка чи масив


// }

// foo(1, 2, 3);
// foo(1, 2, 3, 4, 5, 6);
// foo(1, 2, 3, 4, 5, 6, 7, 8, 9);

// По факту є одна функція, але в неї передається різна кількість аргументів.
// Під час виклику функції передаються аргументи.
// Під час створення функції вона приймає параметри.
// Як працювати з функцією, коли ми не знаємо, яку кількість аргументів вона приймає?
// Для вирішення таких ситуацій у функції існує, за дефолтом, сутність, яка називається arguments. За межами функції arguments не існує. 
// Сутність схожа на масив, але ним не являється - це псевдомасив.
// Псевдомасив - це список, у якого індексовані елементи, має властивість довжини, можна ітеруватися за допомогою циклів.
// Різниця між масивом і псевдомасивом в тому, що у псевдомасиві немає методів масиву (при виклику буде помилка в консолі).
// Аргументи, які передаються в функцію зберігаються у псевдомасиві arguments, незалежно від кількості.
// Гарною практикою є перетворення псевдомасива у масив.
// Для того, щоб перетворити псевдомасив у масив, звертаються до глобального Array, який просто існує в JS, і за допомогою методу from(), в який ми передаємо arguments і здійснюється перетворення в масив.
// Для здійсненя перевірки чи справді це масив ми звертаємося до глобального Array і викликаємо метод isArray(), в який аргументом передаємо масив, який підлягає перевірці. Повертає бульове значення true false.
// Це питання дуже люблять ставити на співбесідах, як дізнатися, що у нас масив, а не об'єкт? 
// Тобто перетворити псевдомасив у масив ми можемо за допомогою Array.from
// А перевірити, що у нас дійсно масив, можна з допомогою Array.isArray() де як аргумент передаємо ті дані, які перевіряємо.



/**
 * Напиши фукцію add для складання довільної
 * кількості аргуметів (чисел)
 */

// function add() {
//   const args = Array.from(arguments);
//   // console.log(Array.isArray(args));
//   // console.log(typeof args[0]);
  
//   let sum = 0;

//   for (const item of args) {
//     sum += item;
//     // console.log(item);
    
//   }
//   // console.log(sum);

//   return sum;
  
// }

// console.log(add(3, 2, 1));
// console.log(add(1, 2, 3, 5, 6));
// console.log(add(1, 2, 3, 5, 7, 8, 9));
// console.log(add(1, 2, 3, 5, 6, 6, 8, 5));

// У функціональному виразі викликати функцію перед її оголошенням не можна буде помилка у консолі. Тому що, функція оголошується за допомогою змінної з ключовим словом const, отже отримати доступ до змінної, до того, як її було ініціалізовано (створено) неможливо, і вибиває помилку у консолі.



// Можна не перетворювати псевдомасив у масив, а просто ітеруватися по ньому

// const add = function() {
//   let total = 0;

//   for(const item of arguments) {
//     // console.log(item); // в item збергаються 
//                           // значення елементів псевдомасиву
    
//     total += item;
//   }
//   return total;
// }

// console.log(add(1, 2, 3));
// console.log(add(1, 2, 3, 4, 5, 6));



/**
 * Напиши функцію calAverage() яка приймає довільну 
 * кількість
 * аргументів і повертає їхнє середнє значення. 
 * Усі аргументи
 * будуть лише числами.
 */

// function calAverage() {
//   const arr = Array.from(arguments);
//   let sum = 0;

//   for (const num of arr) {
//     sum += num;
//   }
//   return sum / arr.length
// }

// console.log(calAverage(1, 2, 3, 4, 5));
// console.log(calAverage(1, 2, 3, 4));
// console.log(calAverage(10, 2, 13, 6, 11));





// ======================================= 2

/**
 * - Глобальна область видимості
 * - Блочна область видимості
 * - Пошук за ланцюжком областей видимості
 */

// const c = 10; // глобальна область

// function foo() {
//   const a = 5; // локальна або блочна область
// }

// foo();
// console.log(c);

// До змінної створеної в глобальній області видимості можна отримати доступ в будь-якому місці коду.
// Будь-які фігурні дужки створюють блочну або локальну область видимості.
// Як відбувається пошук змінної по областям видимості.
// Спочатку відбувається пошук у тій області видимості, де потрібно отримати значення змінної, якщо в тій області немає, то здійснюється перехід а один рівень вище, і відбувається пошук, і так далі до глобальої області. Якщо у глобальній області теж немає, то виб'є помилку, що змінна не ініцалізована.
// Отримати доступ до змінної поза межами області видимості, де вона бул створена неможливо, помилка у консолі.



// ======================================= 3

/**
 * - Стек викликів
 * - Порядок виконання
 */


// Стек виклику упорядковує або слідкує за правильною постановкою послідовності виконання нашого коду
// Під час виклику функції всередині її тіла можуть викликатися інші функції, а в них інші тощо.
// JS однопотокова мова, тобто в одну одиницю часу може виконуватися тільки одна інструкція. Це ознчає, що вже викликані функції, які не закінчили своє виконання, повинні чекати виконання функцій, викликаних всередині себе, для того щоб продовжити свою роботу 

// function fnA() {
//   console.log("fnA");
// }

// function fnB() {
//   console.log("fnB");
// }

// function fnC() {
//   console.log("fnC");
// }

// console.log("before fnA");
// fnA();
// console.log("after fnA");

// console.log("before fnB");
// fnB();
// console.log("after fnB");

// console.log("before fnC");
// fnC();
// console.log("after fnC");

// Щоб код працював контрольовано і очікувано, потрібен механізм зберігання списку функцій, які були викликані, але ще не закінчили своє виконання, і механізм управління послідовністю виконання функцій. Саме за це відповідає стек викликів (call stack).

// Стек - структура данних, яка працює за принципом LIFO (Last-In-First-Out), тобто останнім прийшов - першим вийшов. (Це як складаються млинці на тарілці під час їх приготування). Останнє, що додається на стек, буде видалено з нього першим, значить, можна додати або видалити елементи тільки з верхівки стека

// Стек викликів - це структура даних, яка допомагає інтерпретатору відстежувати послідовність і стан викликів функцій у програмі. Він показує, яка функція зараз виконується і яка буде викликана наступною.

// Коли в коді викликається функція, інтерпретатор додає її в стек викликів і починає виконання.
// Будь-які функції, викликані виконуваною функцією, додаються до стеку викликів і виконуються, щойно відбувається їхній виклик.
// Коли виконання функції завершено, інтерпретатор знімає її зі стеку викликів і відновлює виконання коду з тієї точки, де зупинився до цього. Тобто починає виконуватися функція, запис якої лежить наступою на стеку.

// Стек викликів не безмежний, йому відводиться кінцевий обсяг пам'яті. Іноді в консолі можна побачити помилку "Uncaught RangeError: Maximum call stack size exceeded" — переповнення стека (stack overflow).

// Це може статися при зациклюванні викликів функцій, тобто якщо йдуть нескінченні виклики функцій і результат не повертається, то стек збільшується. Наприклад, якщо функція викликає сама себе, що називається рекурсією. По досягненню межі кількості записів стека і виникне така помилка, і скрипт "падає".

// Можна переглянути як це працює у вкладці sourse devtools, потрібно тільки поставити брейкпоінти

// function bar() {
//   baz();
//   console.log("bar");
// }

// function baz() {
//   console.log("baz");
// }

// function foo() {
//   console.log("foo");
//   bar();
//   console.log("end");
  
// }

// foo();



/**
 * Напиши функцію logItems(items), яка отримує масив та використовує цикл,
 * який для кожного елемента масиву буде виводити в консоль повідомлення у
 * форматі <номер елемента> - <значення елемента>. Нумерація елементів
 * повинна починатися з 1.
 * 
 * Наприклад для першого елемента масиву ['Mango', 'Poly', 'Ajax'] з
 * індексом 0 буде виведено 1 - Mango, а для індексу 2 виведе 3 - Ajax
 */


// function logItems(items) {
//   for (let i = 0; i < items.length; i++) {
//     console.log(`${i +1} - ${items[i]}`);
    
//   }

// }

// logItems(['Mango', 'Poly', 'Ajax']);
// logItems(['🍎', '🍇', '🍑', '🍌', '🍋']);


/**
 * Напиши функцію printInfo(names, phones), яка виводить
 * у консоль імя та телефонний номер користувача. У параметри
 * names та phones будуть передані рядки імен та телефонних номерів,
 * розділені комами. Порядковий номер імен та телефонів у рядках
 * вказують на відповідність. Кількість імен та телефонів 
 * гарантовано однакова.
 */

// function printInfo(names, phones) {
//   const namesArr = names.split(",");
//   const phonesArr = phones.split(",");
  
//   for(let i = 0; i < namesArr.length; i++) {
//     console.log(namesArr[i], phonesArr[i]);
    
//   }
// }


// printInfo(
//   "Jacob,William,Solomon,Artemis",
//   "38001234567,38001112233,380055566377,380055566300"
// );


/**
 * Напиши функцію formatTime(totalMinutes) яка переведе значення
 * totalMinutes (кількість хвилин) у рядок у форматі годин
 * та хвилин HH:MM.
 */

// function formatTime(totalMinutes) {
//   const hours = Math.floor(totalMinutes / 60);
//   const minutes = totalMinutes % 60;

//   const doudleHours = String(hours).padStart(2, 0)
//   const doudleminutes = String(minutes).padStart(2, 0)

//   return `${doudleHours}:${doudleminutes}`
// }

// // padStart() перевіряє чи довжина нашого рядка співпадає з потрібною, яку ми йому передаємо під час виклику як перший аргумент.
// // Якщо довжина рядка співпадає з першим аргументом, то він нічого не буде робити.
// // Якщо довжина менша за це значеня, тоді він на початок рядка додасть символи, які ми передаємо йому, як другий аргумент.

// console.log(formatTime(70));
// console.log(formatTime(460));
// console.log(formatTime(1441));


/**
 * Створити функцію яка буде розбивати початковий масив 
 * на потрібну кількість елементів розділюячи на декілька 
 * масивів. Функція приймає 2 параметри
 * 1 - масив значень
 * 2 - потрібну кількість елементіа в масиві
 * Функція повертає масив масивів
 */


// const data = [1, 2, 3, 4, 5, 6, 7, 8, 9];

// function foo(arr, count) {

//   const res = [];

//   for(let i = 0; i < arr.length; i += count) {
//     // console.log(i);

//     const newArr = arr.slice(i, i + count);
//     // console.log(newArr);
//     res.push(newArr);
//   }

//   return res
// }

// console.log(foo(data, 3));


// Метод splice()

// Метод splice() дуже універсальна штука.
// Він може щось вирізати з масиву.
// Щось додавати у масив.
// Щось вирізати і додавати у місце, де він щось вирізав.
// Метод змінює вихідний масив

// Перший сценарій

// Для того, щоб щось вирізати потрібно в першим аргументом передати індекс, з якого потрібно почати вирізати. Другим аргументом, на відміну від методу slice(), ми передаємо не індекс останнього елемента, до якого хочемо вирізати, а довжину, скільки елементів ми хочемо вирізати.
//  В той самий час, цей метод мутує вихідний масив, тобто у вихідному масиві вирізаних елементів вже не буде. 

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];

// const res = courses.splice(2, 2); 
// console.log("res", res); // поверне ['JS', 'React']
// console.log("courses", courses); // поверне ['HTML', 'CSS', 'Postgres']

// Другий сценарій

// Для того, щоб замість елемента, який вирізається з масиву, вставити інший елемент, потрібно у метод splice() третім аргументом передати значення елемента, яке порібно поставити на місце вирізаного елемента. 
// У змінній res отримаємо елемент, який вирізали з масиву, тобто масив із значенням 'JS'.
// А у змінній courses на місце вирізаного елемента 'JS' зявився "Hello" новий, який ми додали у методі, як третій аргумент.
// Якщо потрібно декілька покласти, то можемо і декілька покласти


// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];

// const res = courses.splice(2, 1, "Hello"); 
// console.log("res", res); // поверне ['JS']
// console.log("courses", courses); 
// // поверне ['HTML', 'CSS', 'Hello', 'React', 'Postgres']

// Третій сценарій

// Якщо не потрібно нічого вирізати, а лише додати елемент до масиву, то таке теж можливо. Ми вказуємо методу індекс куди потрібно вставити новий елемент.
// У змінній res отримаємо порожній масив, оскльки ми нічого не вирізали.
// А у змінній courses на індекс номер 2 стане елемент 'lalala', який ми додали у методі, як третій аргумент.

// const courses = ["HTML", "CSS", "JS", "React", "Postgres"];

// const res = courses.splice(2, 0, "lalala"); 
// console.log("res", res); // поверне []
// console.log("courses", courses); 
// // поверне ['HTML', 'CSS', 'lalala', 'JS', 'React', 'Postgres']


// function foo(arr) {
//   const res = arr.slice();
//   const lastIndex = res.length - 1;

//   for(let i = lastIndex; i >= 0; i--) {
//     arr[lastIndex - i] = res[i];
//   }

//   return arr;
// }

// console.log(foo([12, 85, 37, 4]));
