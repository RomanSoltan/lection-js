// ================================================= 1

/**
 * Перетворення типів: числа
 *
 * - Явне перетворення типів
 * - Неявне перетворення типів
 */

// console.log(10 + "30"); //конкатенація поверне "1030"

// 1.  Явне перетворення типів до числа.

// Для того, щоб перевести тип до числа використовується Number();

// console.log(Number("5")); //поверне число 5. Був тип даних рядок "5".
// console.log(Number(true)); // поверне число 1. Був тип даних буль.
// console.log(Number(false)); // поверне число 0. Був тип даних буль.
// console.log(Number(null)); // поверне число 0. Був тип даних object.

// console.log(Number(undefined)); // поверне NaN, який має тип number. Був тип даних undefined, який призначається автоматично і буквально означає не визначено (нічого), а з нічого зробити щось неможливо, тому поверне NaN(не число), який має тип даних number (парадокс?).

// console.log(Number("Alice")); // поверне NaN, який має тип number.
// console.log(Number("25px")); // поверне NaN, який має тип number. Mетод Number() буде поелементно перебирати наші значення в рядочку і потім натикається на елемент (літера "р"), який він не може перетворити на число. Якщо метод Number() натикається на елемент, який він не може перетворити на число, то він повертає нам NaN.

// 2. Неявне перетворення типів до числа.

// Всі оператори, окрім додавання, будуть виконувати перетворення типу рядка на число і буде відбуватися звичайна математична дія.
// console.log("5" * 2); // поверне число 10.
// console.log("5" - 2); // поверне число 3.
// console.log("5" / 2); // поверне число 2,5.

// Якщо ми виконуємо дії з елементами, які мають тип числа, то відбувається неявне перетворення типу буля(true=1, false=0), null(перетвориться на 0), undefined(перетвориться на NaN) до числа і здійснюється математична дія.
// console.log(5 + true); // поверне число 6. (Відбувається неявне перетворення true до числа 1).
// console.log(5 + false); // поверне число 5. (Відбувається неявне перетворення false до числа 0).

// console.log(5 + null); // поверне число 5.
// console.log(5 + undefined); // поверне число NaN.

// ================================================= 2
/**
 * Опертори
 *
 * - Оператор порівняня
 * - Оператор рівності
 * - Приведення типів операнда
 */

// 1. Опертори порівняння

// console.log(5 > 4); // Перевіряється чи операнд зліва більший за оперенд зправа. Якщо значення зліва більше за значення зправа, то результатом цього виразу буде (повертається) булеве значення true, в іншому випадку - false.

// console.log(10 >= "7"); // Відбудеться перетворення рядка "7" до числа 7, і повернеться результат виразу булеве значення true.

// console.log("2" > "12"); // Коли обидва операнди (значення зліва і значення зправа) є рядками, то перевірка операндів відбувається за юнікодом посимвольно, тобто для перевірки візьметься перший символ рядка зліва ("2") і перший символ рядка зправа ("1"), і запитується 2 більше за 1? Відповідь: так. На цьому перевірка припиняється і далі (далі не цікаво) символи не порівнюються. Отже повернеться булеве значення true.

// 2. Оператор рівності

// Оператор несуворої рівності (" == ") буде приводити операнди до єдиного типу(числа), тобто приведення типів, і лише після цього відбудеться перевірка виразу. Результатом перевірки буде булеве значення true або false.

// console.log("4" == 4); // рядок приведеться до числа (4) і відбудеться перевірка виразу. Повернеться булеве зачення true.

// console.log("Alice" == 4); // рядок приведеться до числа (NaN) і відбудеться перевірка виразу. Повернеться булеве зачення false.

// Оператор суворої рівності (" === ") не буде відбуватися неявного приведення типів, і він порівнює тип і значення елемента (операнда) зліва і зправа. Якщо хоча б типи різні він повертає нам вже одразу false.

// console.log("6" === 6); // рядок не приведеться до числа і відбудеться перевірка виразу. Повернеться булеве значення false.

// console.log("false" === false); // поверне false.
// console.log(1 == true); // поверне true. відбудеться приведення типів до числа
// console.log("0" == false); // true
// console.log("0" === false); // false. Не буде приведення до числа

// console.log("Alice" < "alice"); // Коли порівнюються два рядки, то відбувється перевірка за юнікодом і приведення до числа. І запамятати, що символ у нижньому регістрі завжди має більше значення за символ у верхньому регістрі. Повернеться булеве значення true.

// console.log(undefined == null); // Поверне true. Тому що, undefined буде приведений не до числа, а до значення null. А null == null.

// ================================================= 3
/**
 * Арифметичні функції
 *
 * - Number.parseInt
 * - Number.parseFloat
 * - Math
 */

// Number.parseInt перевіряє елемент посимвольно і приводить до числа, але як тільки потрапляє на символ, який він не може перетворити на число, припиняє свою роботу і повертає те, що вже перетворив на число до цього моменту.
// let width = "50px";
// width = Number.parseInt(width);
// console.log(width); // поверне число 50

// Number.parseFloat працює аналогічно .parseInt, але він вміє працювати з десятковою частиною, тобто коли він натикається на крапочку, то не припиняє свою роботу, а записує крапку і йде шукати далі.
// let height = "20.5px";
// height = Number.parseFloat(height);
// console.log(height); // поверне число 20.5

/**
 * Напиши скрипт, який виводить у консоль заокруглені вгору/вниз і т.д. значення змінної value. Використовуй методи Math.floor(), Math.ceil(), Math.round(). Перевір що буде в консолі при значеннях 27.3 та 27.9.
 */

// const value = 27.5;

// console.log(Math.floor(value)); // Поверне число 27. Метод Math.floor() округлює значення донизу до найближчого цілого числа.

// console.log(Math.ceil(value)); // Поверне число 28. Метод Math.ceil() округлює значення догори до найближчого цілого числа.

// console.log(Math.round(value)); // Поверне число залежить від значення. Метод Math.round() це звичайне математичне округлення до найближчої цілої частини.

// ================================================= 4
/**
 * Функції
 *
 * - Оголошення та виклик функції
 * - Параметри та аргументи
 * - Повернення значення
 */

// Функція - це ізольовний, окремий шматок коду, який ми можемо викликати тоді, коли нам це буде потрібно.

// Оголошення функції

// function add() {}
// функція створена, де function - ключове слово; add - назва функції; () - де оголошуються параметри функції, можуть залишатися порожніми; {} - тіло функції, де власне записується код, який має виконати функція. Код, який живе у тілі функції, виконується лише тоді, коли ця функція викликана.

// Виклик фунціїї

// function add() {
//   console.log("Hello");
// }
// add();
// Для того, щоб наш код, який записаний у функції add відпрацював, нам нашу функцію потрібно викликати. Для того щоб її викликати, ми звертаємося за її ім'ям і ставимо круглі дужки.

// Параметри та аргументи функції

// Під час створення функції, ми можемо отримати у круглих дужках параметри, їх може бути декілька (через кому) або не бути взагалі. Назва параметрів довільна.
// напр.
// function add(параметри, параметри, параметри) {}

// Аргументи передаються під час виклику функції і прописуються у круглих дужках, якщо їх декілька, то прописуються через кому.
// напр.
// add(аргумент, аргумент, аргумент);

// function add(x, y) {
//   console.log(x + y);
// }

// add(5, 2);
// add(5, 12);
// add(15, 12);

// function add(x, y) {
//   console.log(x + y);
// }

// const a = 5;
// const b = 2;

// add(a, b);
// Під час вклику функції передаються назви змінних(a, b) як аргументи, в яких лежать значення. Парметри мають довільну назву, у нашому випадку (x, y).
// Якщо не передамо другий аргумент під час виклику функції, то поверне undefined.

// Оператор return. Повернення значення

// Для того, щоб з нашої функції назовні повернути значення, у нас існує ключове слово return, яке повертає в місце виклику функції результат виконання коду функції і одразу припиняє виконання нашої функції. Якщо в нашій функції немає ключового слова return, тоді функція поверне undefined.

// function add(x, y) {
//   const res = x + y;
//   return res; // зупиняємо виконання коду і повертаємо результат у місце виклику функції add.
// }

// const a = add(5, 2); // зберігається до змінної(а) результат виконання функціїї add.
// console.log("a", a);

// const b = add(10, 15); // зберігається до змінної(b) результат виконання функціїї add.
// console.log("b", b);

// Задача про трьох працівників

// function add(x, y) {
//   const dayTotal = x * 8 * 1.2;
//   return dayTotal * y;
//   return 5; // відпрацює тільки попередній return. Коли функція натикається на return, вона припиняє своє виконання коду. Все що написано після першого return не буде працювати і до виконання другого return не дійде.
// }

// const petro = add(20, 20);
// const kate = add(20, 15);
// const yurii = add(17, 21);

// const petro = 20 * 8 * 20 * 1.2;
// const kate = 20 * 8 * 15 * 1.2;
// const yurii = 17 * 8 * 21 * 1.2;

// console.log("petro", petro);
// console.log("kate", kate);
// console.log("yurii", yurii);

// Задача на розгалуження

// function check(name, age) {
//   if (Number(age) === 18) {
//     return `Вітаю ${name} ти ще молода`;
//   } else {
//     return `Іди за ліками`;
//   }
// }

// let user1 = prompt("Скільки тобі років?");
// user1 = check("Alice", user1);

// console.log(user1);

// ================================================= 5

/**
 * Область видимості функції
 */

// Є два типи областей видимості:
// глобальна (та, яка існує за межами будь-яких фігурних дужок{})
// локальна (існує в межах фігурних дужок{}).

// Ця змінна str створена у глобальній області видимості. Якщо змінна створена у глобальній області видимості, то ми будемо мати доступ до неї у будь-якому місці нашого коду.
// Коли в коді з'являються фігурні дужки, вони створюють локальну область видимості. Змінна message створена у локальні області видимості і ми зможемо отримати до неї доступ тільки в тій області, в якій ми її створили. За межами області видимості(за фігурними дужками) не буде до змінної доступу і буде помилка у консолі.
// Змінні можуть занурюватися вниз в області видимості, а випливати з них вгору в інші області видимості змінні не можуть.
// Видимість залежить від того в якій області шукаєш.

// const str = "hello"; // змінна в глобльній області видимості, буде доступна в будь-якому місці нашого коду

// function foo() {
//   const message = "world"; // нема доступу за межами {}
//   console.log(str);
//   console.log(message);

//   function lala() {
//     const a = "toto";
//     console.log(a); // Видно тільки в локальній області
//   }

//   lala();
// }

// foo();
// console.log(message); // виникне помилка, оскільки у глобальній області видимості такої змінної не існує.

/**
 * Напиши функцію calcBMI(weight, height), яка розраховує та повертає
 * індекс маси тіла людини. Для цього необхідно розділити вагу на
 * квадрат висоти.
 *
 * Вага та висота будуть спеціально передані як рядки. Не цілі числа
 * можуть бути задані у вигляді 24.7 або 24,7, тобто як роздільник
 * дробової частини може бути кома.
 *
 * Індекс маси тіла необхідно округлити до однієї цифри після коми.
 */

// function calcBMI(weight, height) {
//   let numWeight = weight.replace(",", ".");
//   numWeight = Number.parseFloat(numWeight);
//   const numHeight = Number.parseFloat(height);
//   const bmi = numWeight / numHeight ** 2;
//   return bmi.toFixed(1);
// }

// const bmi = calcBMI("88,3", "1.75");
// console.log(bmi);
