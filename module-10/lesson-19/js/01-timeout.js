/* ======================================================================================================================
Знайомство з асинхронним кодом
====================================================================================================================== */

/*синхронний код - виконується поступово і послідовно
Консолі виведуться в тому порядку, в якому написані у коді

Особливість синхронного коду в тому, що наступна 
інструкція коду не буде виконуватися, поки не 
виконається попередня інструкція.
Спочатку виконається код на 13 рядку, потім на 14 і тд.*/ 

// console.log("a");
// console.log("b");
// console.log("c");
// ------------

/*Це звичайна синхронна поведінка

Напр. між двома консолями буде ресурсоємна 
задача, то допоки ця задача цей цикл не виконається
далі наш код не перейде, console.log("after") ми не 
побачимо*/ 

// console.log("before");

// for(let i = 0; i < 10000; i++) {

// }

// console.log("after");

/* ======================================================================================================================
Метод window.setTimeout(callback, delay, args)
====================================================================================================================== */

/*Асинхрон працює трішки інакше

Почнемо знайомство з асинхроном з 
методу window.setTimeout(callback, delay, args).

Що робить цей метод?
Функція setTimeout відкладає на певний час запуск 
колбек функції, яку отримує як аргумент.

Метод setTimeout приймає в себе два аргументи:
  1. колбек функція
  2. час у мілісекундах, на який відкладається
запуск першого аргумента, тобто колбек.

Це ознчає, що спочатку ми побачимо у консолі
before, потім after, а тільки через дві секунди
побачимо timeout.

setTimeout існує для того, щоб відкладено 
запустити якусь функцію*/ 

// console.log("before");

// setTimeout(() => {
//   console.log("timeout");
  
// }, 2000);

// console.log("after");

/*Коли setTimeout порапляє в стек виклику, то
стек розуміє, що setTimeout це асинхронний код і 
направляє його до webapi, де чекає час затримки, 
а потім порапляє до черги (послідовність у черзі 
формується часом затримки у функціях), це дає 
можливість реалізувати асинхронність, тобто 
setTimeout чекає на час свого виконання у черзі, 
поки стек виклику не буде порожнім. 
Коли стек виклику порожній, setTimeout потрапляє в 
стек виклику і виконується.*/ 

// setTimeout(() => {
//   console.log("timeout");
// }, 0)

/*Затримки у нуль мілісекунд не існує, якась 
мінімальна затримка мінімум 4мс, в будь-якому 
випадку буде, але може бути і більше це залежить 
від навантаженості процесора*/ 

/* ======================================================================================================================
Можливість передати параметри для колбеку
====================================================================================================================== */

/*Є можливість створювати функцію ззовні
і потім передавати посилання на неї в setTimeout.
Якщо функція logger хоче отримувати в себе певні 
параметри, то ці параметри можна передати в 
setTimeout після перших двох аргументів, передати 
аргументи, які повинні бути передані у logger.
*/ 

// const logger = (time) => {
//   console.log(`logger ${time}`);
// };

// setTimeout(logger, 2000, "2с");

// ------------------

/*Якщо потрібно передати багато параметрів, їх 
можна передати у вигляді обєкта*/ 

// const logger = ({time}) => {
//   console.log(`logger ${time}`);
// };

// setTimeout(logger, 2000, {time: "2s"});

// ====================

/* ======================================================================================================================
Припинення роботи setTimeout
====================================================================================================================== */

/*Виклик методу setTimeout повертає в місці
свого виклику ідентифікатор цього setTimeout.
його можна зберегти в змінну і використаи 
це значення для зупинки мого setTimeout.
Нас не цікавить, яке значення прилітає у змінну,
нас цікавить саме значення, тобто те, що воно 
взагалі є.
Значення для зупинки setTimeout, беремо як результат 
виклику методу setTimeout, а далі викликаємо метод,
який називається clearTimeout(), в який передаємо як 
аргумент ID числовий ідентифікатор setTimeout, 
який ми хочемо зупинити*/ 

// const logger = ({ time }) => {
//   console.log(`logger ${time}`);
// }

// const timerId = setTimeout(logger, 2000, { time: "2s" });
// clearTimeout(timerId);

// =================

/*Розбір питання з кахуту*/

// for(let i = 3; i > 0; i--) {
//   const delay = i * 1000;
  
//   setTimeout(() => {
//     console.log(i);
//   }, delay);
// }
// 1, 2, 3