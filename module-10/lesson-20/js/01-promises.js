/* ======================================================================================================================
Створення та обробка промісу
====================================================================================================================== */

/**
 * Створення та обробка промісу
 *  - Клас Promise
 *  - resolve
 *  - reject
 *  - then, catch, finally
 */

/*Проміс - це обєкт, який показує поточний стан 
асинхронної операції*/

/* Створимо проміс 
  1. Для того, щоб самостійно потрібно звернутися до 
глобального класу з таким іменем Promise і створити
його екземпляр.
  2. Клас Promise приймає в себе колбек функцію(executor).
Функцію створимо стрілочною.
  3. Стрілочна функція приймає в себе два праметри 
    - resolve
    - reject
Ці параметри, які передаються в колбек, краще не називати
довільно, а використовувати назви за замовчуванням resolve 
та reject
  4. Оскільки проміс - це обєкт, який показує поточний 
результат нашого асинхронного коду, то проміс може 
знаходитися в трьох станах:
  - pending - очікування
  - fullfield - коли проміс успішно виконався
  - rejected - коли проміс виконався з помилкою*/

// const result = new Promise((resolve, reject) => {

// });

// console.log(result); // Promise {<pending>} undefined

/*
  5. Зімітуємо ситуацію зі станами
  6. В тілі перевірки if, якщо хочемо, щоб проміс 
завершився успіхом, викликаємо метод resolve() і 
в цей метод як аргумент передаємо те значення, яке
проміс має отримати у випадку успішного виконання.
  7. В іншому випадку викликаємо метод reject(), який
приймає в себе аргументом те значення, яке проміс має 
отримати у випадку, коли він завершиться помилкою
  8. Return використовувати у новому екземплярі промісу
у колбек у методі resolve і reject не потрібно. Як тільки
ми викликаємо resolve, наш проміс одразу переходить у 
потрібний стан.
*/

// const result = new Promise((resolve, reject) => {
//   const random = Math.random();

//   setTimeout(() => {
//     if(random > 0.5) {
//       resolve("My Fullfield");
//     } else {
//       reject("My Rejected");
//     }
//   }, 2000)
// });

// console.log(result);

/*
  9. Щоб дістати з промісу результат і обробити його 
для цього існують методи промісу then, catch, finally.
  10. Метод then() обробляє успішне завершення промісу.
then приймає в себе як аргумент коллбек. Ця стрілочна
функція в себе, як параметр, приймає значення, яке 
буде повернуто промісом у випадку, коли проміс 
завершився успіхом
  11. Блок catch() для відловлення помилок.
catch приймає в себе як аргумент коллбек. Ця стрілочна
функція в себе, як параметр, приймає значення, яке 
буде повернуто промісом у випадку, коли проміс 
завершився помилкою.
  12.Вбудовані методи обробки промісу then і catch 
дочекаються доки проміс перейде або в стан fullfield, 
або в стан rejected, і тільки тоді його оброблять.
  13. Метод finally() приймає в себе як аргумент коллбек.
Але ця коллбек функція не приймає в себе жодних параметрів.
Метод finally() - це метод, який відпрацює в будь-якому
випадку, при будь-якому результаті завершення промісу.
Він не знає, як завершится проміс, і тому finally не 
потрібні параметри.
  14. Зверніть увагу, що при обробці промісу спочатку 
йде метод then(а він може бути не один), після йде catch
і якщо нам потібен finally, то пишемо його в самому кінці */

// const result = new Promise((resolve, reject) => {
//   const random = Math.random();

//   setTimeout(() => {
//     if (random > 0.5) {
//       resolve("My Fullfield");
//     } else {
//       reject("My Rejected");
//     }
//   }, 2000);
// });

// result
//   .then((data) => {
//     console.log("then", data);
//   })
//   .catch((error) => {
//     console.log("catch", error);
//   })
//   .finally(() => {
//     console.log("My finally");
//   });

/* ======================================================================================================================
Ланцюжки промісів
====================================================================================================================== */

/**
 * Ланцюжки промісів
 *  - декілька послідовних then
 *  - then повертає проміс
 */

/*
  1. створимо проміс
  2. Обробимо результат промісу
  3. Інколи бувають ситуації, що нам в коллбек потрібно
виконати ще якусь асинхронну або синхронну дію і повернути її
  4. Для того щоб з колбек щось пвернути потрібен return.
  5. then повертає проміс, отже проміс можна обробити then
  6. Таким чиом створюємо ланцюжки промісів.
  7. Після усіх then, викликаємо catch.
  8. В кінці, якщо є необхідність викликаємо finally.
*/ 
// const promise = new Promise((resolve, reject) => {
//   resolve(5);
// });

// promise
//   .then(data => {
//     return data * 2;
//   })
//   .then(value => {
//     return value - 2;
//   })
//   .then(value => console.log(value))
//   .catch(error => console.log(error))
//   .finally(() => console.log("ok"));


// ============================================
// Розбір питання з кахуту

/*не вистачало return у методі then, оскільки у коллбек
функції використовувалось явне повернення, то без return у 
наступний метод then потрапляло undefined*/ 

// const promise = new Promise(resolve => {
//   resolve(10);
// })

// promise
//   .then((value) => {
//     return new Promise(resolve => {
//       resolve(value * 2);
//     })
//   })
//   .then(value => console.log(value));

/* ======================================================================================================================
Послідовність роботи коду
====================================================================================================================== */

/*
Спочатку синхрон потім асинхрон.
Асинхронний код поділяється на дві групи:
  1. Група макропроцес (setTimeout, setInterval)
  2. Група мікропроцес (Promise, addEventListener, observer)
  
Є дві черги. Також є така штука як EventLoop, яка 
відповідає за правильну послідовність коду. 
Спочатку відпрацьовує код з групи 
мікропроцесів (Promise, addEventListener, observer), 
потім одна задача код з групи макропроцес (setTimeout, setInterval).
Якщо є необхідність перерендеру сторінки, щось змінити 
на сторінці, EventLoop це виконує і починає цикл з початку.
Спочатку синхрон, потім асинхрон з мікро, потім один асинхрон з макро*/

// console.log("step 1");

// setTimeout(() => {
//   console.log("step 2");
// }, 0)

// new Promise(resolve => {
//   resolve("step 3");
// })
//   .then(data => console.log(data));

// setTimeout(() => {
//   console.log("step 4");
// }, 0);

// відповідь step 1, step 3, step 2, step 4

// =================================

// console.log("step 1");

// setTimeout(() => {
//   console.log("step 2");
// }, 0)

// new Promise(resolve => {
//   resolve("step 3");
// })
//   .then(data => {
//     console.log(data);
//     return "step 4";
//   })
//   .then(data => console.log(data));

// setTimeout(() => {
//   console.log("step 5");
// }, 0);

// // Відповідь 
// // step 1
// // step 3
// // step 4
// // step 2
// // step 5