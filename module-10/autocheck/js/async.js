/* ======================================================================================================================
Асинхронність

Асинхронні операції
====================================================================================================================== */
/* 
Синхронний код виконується послідовно, кожна 
інструкція очікує, доки виконається попередня. 
Коли ти викликаєш функцію, яка виконує тривалу 
дію, це зупиняє програму на увесь час її 
виконання. Тобто в моделі синхронного 
програмування все відбувається по черзі.
*/ 

/*В асинхронному коді одночасно можуть 
виконуватися декілька операцій. У такій 
моделі мережевий запит на сервер не зупинить 
програму, вона продовжить виконувати інші 
операції. Коли запит завершиться, програма 
повідомляє про це й отримує доступ до 
результату (наприклад, даних із сервера).

Уявімо, що користувач відправив коментар 
(мережевий запит) і водночас захотів відкрити 
сайдбар з останніми новинами. Після кліка 
відправити коментар, інтерфейс зависне і не 
буде реагувати на його дії, доки від сервера 
не прийде результат відправлення коментаря. 
Погодься, це не дуже зручно.

В асинхронній моделі старт мережевого запиту 
викликає щось на зразок розгалуження, тобто 
запуск запиту і результат його обробки — це 
різні дії. Доки виконується запит, програма 
продовжує працювати й виконувати інший код. 
Щойно мережевий запит буде виконаний, програма 
може почати обробляти його результат одразу 
після звільнення. Це означає, що користувач 
відправив коментар і відразу зміг відкрити 
сайдбар зі свіжими новинами, не чекаючи, доки 
прийде відповідь від сервера.

За одиницю часу, як і раніше, може виконуватися 
тільки одна операція, тому що JavaScript — 
однопотокова мова. Асинхронне програмування 
досягається шляхом відкладених викликів функцій, 
де ініціалізація асинхронної операції і обробка 
її результату — це різні дії.*/ 

/* ======================================================================================================================
Асинхронний код
====================================================================================================================== */

/*У синхронному коді інструкції обробляються 
послідовно. Отже, наступна інструкція не може 
почати своє виконання, доки не виконається попередня.*/ 

// console.log("first log");
// console.log("second log");
// console.log("third log");

/*Код нижче — асинхронний. З функцією setTimeout() 
ми познайомимося далі. Зараз про неї нам потрібно 
знати тільки те, що вона приймає два параметри:

callback-функцію, яка буде викликана після закінчення часу;
час, після якого буде викликана функція.*/ 

// // Виконується першою
// console.log("first log");

// setTimeout(() => {
//   // Виконується третьою, через 2000 мілісекунд (2 секунди)
//   console.log("second log");
// }, 2000);

// // Виконується другою
// console.log("third log");

/*Функція setTimeout() відпрацьовує синхронно 
й реєструє відкладений виклик переданої 
callback-функції. Ця функція буде викликана 
асинхронно, через вказаний проміжок часу.

Хоча маємо 3 різні команди console.log(), їх 
порядок виводу може бути не відповідним 
послідовності коду через асинхронну природу 
setTimeout().

Послідовність подій:

  1. Виконується синхронний console.log("First log");,
і в консоль виводиться "First log".
  2. Виконується setTimeout(), який синхронно ставить 
передану функцію в асинхронну чергу на виконання. Але 
через вказану затримку в 2000 мілісекунд (2 секунди), 
виконання цієї функції відкладається на цей час.
  3. Виконується синхронний console.log("Third log");,
і в консоль виводиться "Third log".
  4. Після 2 секунд виконується асинхронний виклик 
функції, переданої в setTimeout(), і в консоль 
виводиться "Second log".*/ 

/* ======================================================================================================================
Багатопотоковість
====================================================================================================================== */

/*Не плутай асинхронність і багатопотоковість (паралелізм)
— це різні моделі програмування. Наведемо просту аналогію, 
яка все розставить на свої місця. Уяви, що ти шеф у 
ресторані, і надходить замовлення на каву і тости.

  Синхронний однопотоковий підхід — ти сам спочатку готуєш 
  каву, потім тости і подаєш їх, після чого прибираєшся 
  на кухні.

  Асинхронний однопотоковий підхід —- ти починаєш готувати 
  каву і встановлюєш таймер, потім починаєш готувати тости 
  і так само встановлюєш таймер. Доки кава і тости готуються, 
  ти прибираєш на кухні. Коли таймери спрацьовують, ти 
  знімаєш з вогню каву, дістаєш тости і подаєш їх.

  Багатопотоковий підхід (паралелізм) — ти наймаєш двох 
  помічників. Одного — для приготування кави, а іншого — 
  для тостів. Тепер у тебе є проблема управління помічниками 
  (потоками), щоб вони не конфліктували один з одним на 
  кухні під час спільного використання ресурсів.

В асинхронних однопотокових процесах у тебе є графік 
завдань, в якому деякі завдання залежать від результату 
роботи інших. З виконанням кожного завдання викликається 
код для обробки його результату.*/ 

/* ======================================================================================================================
Тайм-аут
====================================================================================================================== */

/*Внутрішній таймер-планувальник браузера дозволяє 
відкладати виклик функції на певний період часу. 
Для цього є тайм-аути та інтервали, вони контролюють, 
коли і як часто викликається функція. Таймери 
реалізовані в браузері, а не вбудовані в мову, і 
доступні на глобальному об'єкті window.

Метод setTimeout() дозволяє запланувати одноразовий 
виклик функції через певний час.
*/ 

// const timeId = setTimeout(callback, delay, arg1, arg2);

/*
  1. callback — функція, виклик якої 
необхідно запланувати;
  2. delay — час у мілісекундах, через який 
callback-функція буде викликана один раз.
  3. Додаткові аргументи (arg1, arg2 тощо) не 
обов’язкові і будуть передані callback 
функції під час виклику. 
  4. Результатом виклику setTimout() буде 
цифровий ідентифікатор створеного таймера, 
який потім може бути використаним для його 
подальшого скасування.*/ 

/*У прикладі коду нижче через дві секунди 
після натискання на кнопку в консолі 
розробника з'явиться повідомлення, вказане 
в колбек-функції для setTimeout. При кожному 
натисканні на кнопку буде запускатися новий 
таймер, якому буде присвоюватися новий 
числовий ідентифікатор*/ 

// const button = document.querySelector("button");

// const onClick = () => {
//   const timeId = setTimeout(() => {
//     console.log("I love async JS");
//   }, 2000);

//   console.log(timeId);
// };

// button.addEventListener("click", onClick);

/*Що робить функція setTimeout?

Функція setTimeout планує в асинхронній черзі 
відкладений виклик функції, який виконується 
після зазначеного інтервалу часу. Вона не 
викликає функцію безпосередньо, а лише планує 
її виконання через певний час

Що повертає виклик функції setTimeout?

Виклик функції setTimeout() повертає цифровий 
ідентифікатор створеного таймера.*/ 

/* ======================================================================================================================
Скасування тайм-ауту
====================================================================================================================== */

/*Якщо з якихось причин нам потрібно скасувати 
відкладений виклик функції, зареєстрованої 
тайм-аутом, використовується метод clearTimeout(id).

Метод clearTimeout(id)приймає ідентифікатор таймера 
та "очищає його", тобто видаляє реєстрацію відкладеного 
виклику функції з черги.*/ 

// const greet = () => {
//   console.log("Hello!");
// };

// const timeId = setTimeout(greet, 3000);
// clearTimeout(timeId);

/*У прикладі вище ми викликали clearTimeout(), 
який виконається раніше, ніж буде викликана 
функція greet(). Отже, таймер з timerId буде 
видалений і реєстрація відкладеного виклику 
greet() скасується. Тому в консоль нічого 
не виведеться.*/ 

// ------------

/*У цьому прикладі ми додали кнопку 
скасування таймера «Clear timeout».*/ 

// const setBtn = document.querySelector(".js-set");
// const clearBtn = document.querySelector(".js-clear");
// let timeoutId;

// setBtn.addEventListener("click", () => {
//   timeoutId = setTimeout(() => {
//     console.log("I love async JS");
//   }, 2000);
// });

// clearBtn.addEventListener("click", () => {
//   clearTimeout(timeoutId);
//   console.log(`Timeout with id ${timeoutId} has stopped`);
// });
/*
  1. Кожного разу при натисканні на кнопку 
Set timeout буде створюватися новий таймер, 
якому буде присвоєно новий ідентифікатор.
  2. Натискання на кнопку Clear timeout 
очистить відповідний таймер за переданим 
числовим ідентифікатором.
  3. Якщо потрібно очищати всі таймери, 
можна, наприклад, зберігати ідентифікатори 
всіх запущених таймерів у вигляді масиву, 
перебирати його та послідовно очищати.*/ 

/*Що потрібно передати функції clearTimeout?

Ідентифікатор таймера, який повернув виклик 
setTimeout для скасування виклику переданої 
у setTimeout функції.*/ 

/* ======================================================================================================================
Інтервал
====================================================================================================================== */

/*Метод setInterval() — це простий спосіб 
повторення коду знову і знову з певним інтервалом.

Синтаксис і параметри такі самі, як у setTimeout().*/ 

// const intervalId = setInterval(callback, delay, arg1, arg2);

/*Результатом виклику setInterval() буде цифровий 
ідентифікатор створеного таймера, який потім може 
бути використаним для його подальшого скасування.

На відміну від setTimeout(), інтервал запускає 
виконання функції не один раз, а регулярно 
повторює її через вказаний проміжок часу.*/ 

// ---------

/*У прикладі будемо кожну секунду виводити в 
консоль рядок. Використовуємо Math.random(), 
щоб рядки були різні. Щоразу при натисканні 
на кнопку Start буде створюватися новий 
інтервал, якому буде присвоєно новий 
числовий ідентифікатор.*/ 

// const startBtn = document.querySelector(".js-start");

// startBtn.addEventListener("click", () => {
//   const intervalId = setInterval(() => {
//     console.log(`Interval ID: ${intervalId}, ${Math.random()}`);
//   }, 1000);
// });

/*У браузерного таймера є мінімально можлива 
затримка, вона коливається приблизно від 0 до 
4 мілісекунд. За стандартом, мінімальна затримка 
становить 4 мілісекунди, тому різниці між 
setInterval(cb, 1) і setInterval(cb, 4) немає.

Таймер може спрацьовувати рідше, ніж зазначено в 
параметрі delay. Адже через занадто велике 
завантаження процесора деякі запуски функцій-інтервалів 
будуть пропущені. Браузери продовжують виконувати 
тайм-аути та інтервали, навіть якщо вкладка браузера 
неактивна, але водночас знижується частота 
спрацьовування таймерів.*/ 

/*Що повертає функція setInterval?

Функція setInterval повертає числовий 
ідентифікатор інтервалу
// ----------

Скільки разів буде викликана функція 
foo для setInterval(foo, 2000)?

Кожні 2 секунди*/

/* ======================================================================================================================
Скасування інтервалу
====================================================================================================================== */

/*Якщо з якихось причин нам потрібно скасувати 
виконання функції, зареєстрованої інтервалом, 
використовується метод clearInterval.*/ 

// clearInterval(id)

/*Він приймає ідентифікатор інтервалу та 
очищає його, тобто видаляє виклики, зареєстровані 
переданим інтервалом з асинхронної черги.*/ 

// const greet = () => {
//   console.log("Hello!");
// };

// const intervalId = setInterval(greet, 3000);
// clearInterval(intervalId);

/*У прикладі вище ми викликали clearInterval(), 
який виконається раніше, ніж буде викликана 
функція greet(). Отже, інтервал з intervalId 
буде видалений і реєстрація відкладеного виклику 
greet() скасується. Тому в консоль нічого не виведеться.*/ 

// ------------

/*У живому прикладі ми додали кнопку скасування 
інтервалу Stop, клікаючи на неї ми викличемо 
clearInterval() і передамо ідентифікатор 
інтервалу, який потрібно зупинити.*/ 

// const startBtn = document.querySelector(".js-start");
// const stopBtn = document.querySelector(".js-stop");
// let intervalId = null;

// startBtn.addEventListener("click", () => {
//   intervalId = setInterval(() => {
//     console.log(`Interval ID: ${intervalId}, ${Math.random()}`);
//   }, 1000);
// });

// stopBtn.addEventListener("click", () => {
//   clearInterval(intervalId);
//   console.log(`Interval with id ${intervalId} has stopped!`);
// });
/*
  1. Кожного разу при натисканні на кнопку Start 
буде створюватися новий інтервал, якому буде 
присвоєно новий ідентифікатор.
  2. Натискання на кнопку Stop очистить відповідний 
інтервал за переданим числовим ідентифікатором.
  3. Якщо потрібно очистити всі інтервали, можна, 
наприклад, зберігати ідентифікатори всіх запущених 
інтервалів у вигляді масиву, перебирати його та 
послідовно очищати.*/ 

/*Що потрібно передати функції clearInterval?

Ідентифікатор інтервалу, який повернув setInterval
*/ 